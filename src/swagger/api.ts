// eslint-disable-next-line @typescript-eslint/triple-slash-reference
/// <reference path="../custom.d.ts" />
// tslint:disable
/**
 * OpenAPI definition
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { isomorphicFetch } from "_@/swagger/isomorphicFetch";
import { Configuration } from "./configuration";

export const BASE_PATH = "http://14.225.205.235:8080".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration | undefined;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  // name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AddNewArRequest
 */
export interface AddNewArRequest {
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  mainImage?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  brief?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  description?: string;
  /**
   *
   * @type {number}
   * @memberof AddNewArRequest
   */
  categoryId?: number;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  keyword?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArRequest
   */
  thumbnail?: string;
}
/**
 *
 * @export
 * @interface AddNewArticleRequest
 */
export interface AddNewArticleRequest {
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  mainImage?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  brief: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  image1?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewArticleRequest
   */
  keyword?: string;
}
/**
 *
 * @export
 * @interface AddNewCommentRequest
 */
export interface AddNewCommentRequest {
  /**
   *
   * @type {number}
   * @memberof AddNewCommentRequest
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof AddNewCommentRequest
   */
  articleId: number;
  /**
   *
   * @type {string}
   * @memberof AddNewCommentRequest
   */
  description?: string;
}
/**
 *
 * @export
 * @interface AddNewLikeRequest
 */
export interface AddNewLikeRequest {
  /**
   *
   * @type {number}
   * @memberof AddNewLikeRequest
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof AddNewLikeRequest
   */
  articleId: number;
}
/**
 *
 * @export
 * @interface AddNewMovieRequest
 */
export interface AddNewMovieRequest {
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  smallImageURl?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  longDescription?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  largeImageURL?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  director: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  actors: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  categories: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  releaseDate: string;
  /**
   *
   * @type {number}
   * @memberof AddNewMovieRequest
   */
  duration: number;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  trailerURL: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewMovieRequest
   */
  rated: string;
  /**
   *
   * @type {number}
   * @memberof AddNewMovieRequest
   */
  isShowing: number;
}
/**
 *
 * @export
 * @interface AddNewReviewRequest
 */
export interface AddNewReviewRequest {
  /**
   *
   * @type {string}
   * @memberof AddNewReviewRequest
   */
  mainImage?: string;
  /**
   *
   * @type {string}
   * @memberof AddNewReviewRequest
   */
  title: string;
  /**
   *
   * @type {string}
   * @memberof AddNewReviewRequest
   */
  brief: string;
  /**
   *
   * @type {string}
   * @memberof AddNewReviewRequest
   */
  description: string;
  /**
   *
   * @type {string}
   * @memberof AddNewReviewRequest
   */
  keyword?: string;
}
/**
 *
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
  /**
   *
   * @type {boolean}
   * @memberof ApiResponse
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof ApiResponse
   */
  message?: string;
}
/**
 *
 * @export
 * @interface ArticleDto
 */
export interface ArticleDto {
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  createdBy?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  modifiedBy?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  updatedAt?: string;
  /**
   *
   * @type {number}
   * @memberof ArticleDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  brief?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  status?: ArticleDto.StatusEnum;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  mainImage?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  image1?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  type?: ArticleDto.TypeEnum;
  /**
   *
   * @type {CategoryDto}
   * @memberof ArticleDto
   */
  category?: CategoryDto;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  keyword?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  slug?: string;
  /**
   *
   * @type {string}
   * @memberof ArticleDto
   */
  thumbnail?: string;
  /**
   *
   * @type {UserDto}
   * @memberof ArticleDto
   */
  user?: UserDto;
  /**
   *
   * @type {number}
   * @memberof ArticleDto
   */
  totalLike?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleDto
   */
  view?: number;
}

/**
 * @export
 * @namespace ArticleDto
 */
export namespace ArticleDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    CREATE = <any>"CREATE",
    APPROVE = <any>"APPROVE",
    DENY = <any>"DENY",
    DELETE = <any>"DELETE",
    DRAFT = <any>"DRAFT",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    REVIEWS = <any>"REVIEWS",
    NEWS = <any>"NEWS",
  }
}
/**
 *
 * @export
 * @interface ArticleReportDto
 */
export interface ArticleReportDto {
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  totalArticleInMonth?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  totalArticleInPreviousMonth?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  articleIsPrevious?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  totalNewUserInMonth?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  totalNewUserInPreviousMonth?: number;
  /**
   *
   * @type {number}
   * @memberof ArticleReportDto
   */
  userIsPrevious?: number;
}
/**
 *
 * @export
 * @interface BillDto
 */
export interface BillDto {
  /**
   *
   * @type {number}
   * @memberof BillDto
   */
  id?: number;
  /**
   *
   * @type {Date}
   * @memberof BillDto
   */
  createdTime?: Date;
  /**
   *
   * @type {UserProfile}
   * @memberof BillDto
   */
  user?: UserProfile;
  /**
   *
   * @type {string}
   * @memberof BillDto
   */
  status?: BillDto.StatusEnum;
  /**
   *
   * @type {number}
   * @memberof BillDto
   */
  price?: number;
}

/**
 * @export
 * @namespace BillDto
 */
export namespace BillDto {
  /**
   * @export
   * @enum {string}
   */
  export enum StatusEnum {
    WAITINGPAYMENT = <any>"WAITING_PAYMENT",
    SUCCESS = <any>"SUCCESS",
    EXPIRATION = <any>"EXPIRATION",
  }
}
/**
 *
 * @export
 * @interface BookingRequestDto
 */
export interface BookingRequestDto {
  /**
   *
   * @type {number}
   * @memberof BookingRequestDto
   */
  userId: number;
  /**
   *
   * @type {number}
   * @memberof BookingRequestDto
   */
  scheduleId: number;
  /**
   *
   * @type {Array<number>}
   * @memberof BookingRequestDto
   */
  listSeatIds: Array<number>;
}
/**
 *
 * @export
 * @interface BranchDto
 */
export interface BranchDto {
  /**
   *
   * @type {number}
   * @memberof BranchDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof BranchDto
   */
  imgURL?: string;
  /**
   *
   * @type {string}
   * @memberof BranchDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BranchDto
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof BranchDto
   */
  phoneNo?: string;
}
/**
 *
 * @export
 * @interface BranchResponse
 */
export interface BranchResponse {
  /**
   *
   * @type {number}
   * @memberof BranchResponse
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof BranchResponse
   */
  imgURL?: string;
  /**
   *
   * @type {string}
   * @memberof BranchResponse
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof BranchResponse
   */
  address?: string;
  /**
   *
   * @type {string}
   * @memberof BranchResponse
   */
  phoneNo?: string;
  /**
   *
   * @type {Array<CusRoom>}
   * @memberof BranchResponse
   */
  rooms?: Array<CusRoom>;
}
/**
 *
 * @export
 * @interface CategoryDto
 */
export interface CategoryDto {
  /**
   *
   * @type {number}
   * @memberof CategoryDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CategoryDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof CategoryDto
   */
  amountArticle?: number;
}
/**
 *
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
  /**
   *
   * @type {number}
   * @memberof CommentDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  username?: string;
  /**
   *
   * @type {number}
   * @memberof CommentDto
   */
  articleId?: number;
  /**
   *
   * @type {number}
   * @memberof CommentDto
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  createdAt?: string;
  /**
   *
   * @type {string}
   * @memberof CommentDto
   */
  lastModifyDate?: string;
}
/**
 *
 * @export
 * @interface CusRoom
 */
export interface CusRoom {
  /**
   *
   * @type {number}
   * @memberof CusRoom
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof CusRoom
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof CusRoom
   */
  capacity?: number;
  /**
   *
   * @type {number}
   * @memberof CusRoom
   */
  totalArea?: number;
  /**
   *
   * @type {string}
   * @memberof CusRoom
   */
  imgURL?: string;
}
/**
 *
 * @export
 * @interface DayTransactionReport
 */
export interface DayTransactionReport {
  /**
   *
   * @type {number}
   * @memberof DayTransactionReport
   */
  transactionCount?: number;
  /**
   *
   * @type {number}
   * @memberof DayTransactionReport
   */
  incomeAmount?: number;
  /**
   *
   * @type {number}
   * @memberof DayTransactionReport
   */
  ticketAmount?: number;
  /**
   *
   * @type {string}
   * @memberof DayTransactionReport
   */
  dateTran?: string;
}
/**
 *
 * @export
 * @interface GetDashboardTransactionResponse
 */
export interface GetDashboardTransactionResponse {
  /**
   *
   * @type {number}
   * @memberof GetDashboardTransactionResponse
   */
  totalTicket?: number;
  /**
   *
   * @type {number}
   * @memberof GetDashboardTransactionResponse
   */
  totalIncome?: number;
  /**
   *
   * @type {number}
   * @memberof GetDashboardTransactionResponse
   */
  totalTransaction?: number;
  /**
   *
   * @type {Array<DayTransactionReport>}
   * @memberof GetDashboardTransactionResponse
   */
  dayTransactionReports?: Array<DayTransactionReport>;
}
/**
 *
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
  /**
   *
   * @type {string}
   * @memberof GrantedAuthority
   */
  authority?: string;
}
/**
 *
 * @export
 * @interface LikeDto
 */
export interface LikeDto {
  /**
   *
   * @type {number}
   * @memberof LikeDto
   */
  id?: number;
  /**
   *
   * @type {number}
   * @memberof LikeDto
   */
  isLike?: number;
  /**
   *
   * @type {string}
   * @memberof LikeDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof LikeDto
   */
  articleId?: number;
  /**
   *
   * @type {number}
   * @memberof LikeDto
   */
  userId?: number;
  /**
   *
   * @type {string}
   * @memberof LikeDto
   */
  createdDate?: string;
  /**
   *
   * @type {string}
   * @memberof LikeDto
   */
  lastModifyDate?: string;
}
/**
 *
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  hour?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  minute?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  second?: number;
  /**
   *
   * @type {number}
   * @memberof LocalTime
   */
  nano?: number;
}
/**
 *
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  usernameOrEmail: string;
  /**
   *
   * @type {string}
   * @memberof LoginRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface MovieDto
 */
export interface MovieDto {
  /**
   *
   * @type {number}
   * @memberof MovieDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  smallImageURl?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  longDescription?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  largeImageURL?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  director?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  actors?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  categories?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  releaseDate?: string;
  /**
   *
   * @type {number}
   * @memberof MovieDto
   */
  duration?: number;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  trailerURL?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof MovieDto
   */
  rated?: string;
}
/**
 *
 * @export
 * @interface PageResponseArticleDto
 */
export interface PageResponseArticleDto {
  /**
   *
   * @type {Array<ArticleDto>}
   * @memberof PageResponseArticleDto
   */
  content?: Array<ArticleDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseArticleDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseArticleDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseArticleDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseArticleDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseBranchDto
 */
export interface PageResponseBranchDto {
  /**
   *
   * @type {Array<BranchDto>}
   * @memberof PageResponseBranchDto
   */
  content?: Array<BranchDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseBranchDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseBranchDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseBranchDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseBranchDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseCommentDto
 */
export interface PageResponseCommentDto {
  /**
   *
   * @type {Array<CommentDto>}
   * @memberof PageResponseCommentDto
   */
  content?: Array<CommentDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseCommentDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseCommentDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseCommentDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseCommentDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseMovieDto
 */
export interface PageResponseMovieDto {
  /**
   *
   * @type {Array<MovieDto>}
   * @memberof PageResponseMovieDto
   */
  content?: Array<MovieDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseMovieDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseMovieDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseMovieDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseMovieDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseScheduleDto
 */
export interface PageResponseScheduleDto {
  /**
   *
   * @type {Array<ScheduleDto>}
   * @memberof PageResponseScheduleDto
   */
  content?: Array<ScheduleDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseScheduleDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseScheduleDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseScheduleDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseScheduleDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseTicketDto
 */
export interface PageResponseTicketDto {
  /**
   *
   * @type {Array<TicketDto>}
   * @memberof PageResponseTicketDto
   */
  content?: Array<TicketDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseTicketDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseTicketDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseTicketDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseTicketDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface PageResponseUserDto
 */
export interface PageResponseUserDto {
  /**
   *
   * @type {Array<UserDto>}
   * @memberof PageResponseUserDto
   */
  content?: Array<UserDto>;
  /**
   *
   * @type {number}
   * @memberof PageResponseUserDto
   */
  number?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseUserDto
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseUserDto
   */
  totalElements?: number;
  /**
   *
   * @type {number}
   * @memberof PageResponseUserDto
   */
  totalPages?: number;
}
/**
 *
 * @export
 * @interface ResponseBase
 */
export interface ResponseBase {
  /**
   *
   * @type {number}
   * @memberof ResponseBase
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBase
   */
  message?: string;
  /**
   *
   * @type {any}
   * @memberof ResponseBase
   */
  data?: any;
}
/**
 *
 * @export
 * @interface ResponseBaseArticleDto
 */
export interface ResponseBaseArticleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseArticleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseArticleDto
   */
  message?: string;
  /**
   *
   * @type {ArticleDto}
   * @memberof ResponseBaseArticleDto
   */
  data?: ArticleDto;
}
/**
 *
 * @export
 * @interface ResponseBaseArticleReportDto
 */
export interface ResponseBaseArticleReportDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseArticleReportDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseArticleReportDto
   */
  message?: string;
  /**
   *
   * @type {ArticleReportDto}
   * @memberof ResponseBaseArticleReportDto
   */
  data?: ArticleReportDto;
}
/**
 *
 * @export
 * @interface ResponseBaseBillDto
 */
export interface ResponseBaseBillDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseBillDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseBillDto
   */
  message?: string;
  /**
   *
   * @type {BillDto}
   * @memberof ResponseBaseBillDto
   */
  data?: BillDto;
}
/**
 *
 * @export
 * @interface ResponseBaseBranchResponse
 */
export interface ResponseBaseBranchResponse {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseBranchResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseBranchResponse
   */
  message?: string;
  /**
   *
   * @type {BranchResponse}
   * @memberof ResponseBaseBranchResponse
   */
  data?: BranchResponse;
}
/**
 *
 * @export
 * @interface ResponseBaseCategoryDto
 */
export interface ResponseBaseCategoryDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseCategoryDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseCategoryDto
   */
  message?: string;
  /**
   *
   * @type {CategoryDto}
   * @memberof ResponseBaseCategoryDto
   */
  data?: CategoryDto;
}
/**
 *
 * @export
 * @interface ResponseBaseCommentDto
 */
export interface ResponseBaseCommentDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseCommentDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseCommentDto
   */
  message?: string;
  /**
   *
   * @type {CommentDto}
   * @memberof ResponseBaseCommentDto
   */
  data?: CommentDto;
}
/**
 *
 * @export
 * @interface ResponseBaseLikeDto
 */
export interface ResponseBaseLikeDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseLikeDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseLikeDto
   */
  message?: string;
  /**
   *
   * @type {LikeDto}
   * @memberof ResponseBaseLikeDto
   */
  data?: LikeDto;
}
/**
 *
 * @export
 * @interface ResponseBaseListArticleDto
 */
export interface ResponseBaseListArticleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListArticleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListArticleDto
   */
  message?: string;
  /**
   *
   * @type {Array<ArticleDto>}
   * @memberof ResponseBaseListArticleDto
   */
  data?: Array<ArticleDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListBranchDto
 */
export interface ResponseBaseListBranchDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListBranchDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListBranchDto
   */
  message?: string;
  /**
   *
   * @type {Array<BranchDto>}
   * @memberof ResponseBaseListBranchDto
   */
  data?: Array<BranchDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListBranchResponse
 */
export interface ResponseBaseListBranchResponse {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListBranchResponse
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListBranchResponse
   */
  message?: string;
  /**
   *
   * @type {Array<BranchResponse>}
   * @memberof ResponseBaseListBranchResponse
   */
  data?: Array<BranchResponse>;
}
/**
 *
 * @export
 * @interface ResponseBaseListCategoryDto
 */
export interface ResponseBaseListCategoryDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListCategoryDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListCategoryDto
   */
  message?: string;
  /**
   *
   * @type {Array<CategoryDto>}
   * @memberof ResponseBaseListCategoryDto
   */
  data?: Array<CategoryDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListLikeDto
 */
export interface ResponseBaseListLikeDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListLikeDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListLikeDto
   */
  message?: string;
  /**
   *
   * @type {Array<LikeDto>}
   * @memberof ResponseBaseListLikeDto
   */
  data?: Array<LikeDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListMovieDto
 */
export interface ResponseBaseListMovieDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListMovieDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListMovieDto
   */
  message?: string;
  /**
   *
   * @type {Array<MovieDto>}
   * @memberof ResponseBaseListMovieDto
   */
  data?: Array<MovieDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListScheduleDto
 */
export interface ResponseBaseListScheduleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListScheduleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListScheduleDto
   */
  message?: string;
  /**
   *
   * @type {Array<ScheduleDto>}
   * @memberof ResponseBaseListScheduleDto
   */
  data?: Array<ScheduleDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListSeatDto
 */
export interface ResponseBaseListSeatDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListSeatDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListSeatDto
   */
  message?: string;
  /**
   *
   * @type {Array<SeatDto>}
   * @memberof ResponseBaseListSeatDto
   */
  data?: Array<SeatDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListTicketDto
 */
export interface ResponseBaseListTicketDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListTicketDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListTicketDto
   */
  message?: string;
  /**
   *
   * @type {Array<TicketDto>}
   * @memberof ResponseBaseListTicketDto
   */
  data?: Array<TicketDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseListUserDto
 */
export interface ResponseBaseListUserDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseListUserDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseListUserDto
   */
  message?: string;
  /**
   *
   * @type {Array<UserDto>}
   * @memberof ResponseBaseListUserDto
   */
  data?: Array<UserDto>;
}
/**
 *
 * @export
 * @interface ResponseBaseMovieDto
 */
export interface ResponseBaseMovieDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseMovieDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseMovieDto
   */
  message?: string;
  /**
   *
   * @type {MovieDto}
   * @memberof ResponseBaseMovieDto
   */
  data?: MovieDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseArticleDto
 */
export interface ResponseBasePageResponseArticleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseArticleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseArticleDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseArticleDto}
   * @memberof ResponseBasePageResponseArticleDto
   */
  data?: PageResponseArticleDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseBranchDto
 */
export interface ResponseBasePageResponseBranchDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseBranchDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseBranchDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseBranchDto}
   * @memberof ResponseBasePageResponseBranchDto
   */
  data?: PageResponseBranchDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseCommentDto
 */
export interface ResponseBasePageResponseCommentDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseCommentDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseCommentDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseCommentDto}
   * @memberof ResponseBasePageResponseCommentDto
   */
  data?: PageResponseCommentDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseMovieDto
 */
export interface ResponseBasePageResponseMovieDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseMovieDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseMovieDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseMovieDto}
   * @memberof ResponseBasePageResponseMovieDto
   */
  data?: PageResponseMovieDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseScheduleDto
 */
export interface ResponseBasePageResponseScheduleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseScheduleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseScheduleDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseScheduleDto}
   * @memberof ResponseBasePageResponseScheduleDto
   */
  data?: PageResponseScheduleDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseTicketDto
 */
export interface ResponseBasePageResponseTicketDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseTicketDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseTicketDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseTicketDto}
   * @memberof ResponseBasePageResponseTicketDto
   */
  data?: PageResponseTicketDto;
}
/**
 *
 * @export
 * @interface ResponseBasePageResponseUserDto
 */
export interface ResponseBasePageResponseUserDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBasePageResponseUserDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBasePageResponseUserDto
   */
  message?: string;
  /**
   *
   * @type {PageResponseUserDto}
   * @memberof ResponseBasePageResponseUserDto
   */
  data?: PageResponseUserDto;
}
/**
 *
 * @export
 * @interface ResponseBaseScheduleDto
 */
export interface ResponseBaseScheduleDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseScheduleDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseScheduleDto
   */
  message?: string;
  /**
   *
   * @type {ScheduleDto}
   * @memberof ResponseBaseScheduleDto
   */
  data?: ScheduleDto;
}
/**
 *
 * @export
 * @interface ResponseBaseUserDto
 */
export interface ResponseBaseUserDto {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseUserDto
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseUserDto
   */
  message?: string;
  /**
   *
   * @type {UserDto}
   * @memberof ResponseBaseUserDto
   */
  data?: UserDto;
}
/**
 *
 * @export
 * @interface ResponseBaseUserSummary
 */
export interface ResponseBaseUserSummary {
  /**
   *
   * @type {number}
   * @memberof ResponseBaseUserSummary
   */
  code?: number;
  /**
   *
   * @type {string}
   * @memberof ResponseBaseUserSummary
   */
  message?: string;
  /**
   *
   * @type {UserSummary}
   * @memberof ResponseBaseUserSummary
   */
  data?: UserSummary;
}
/**
 *
 * @export
 * @interface RoomDto
 */
export interface RoomDto {
  /**
   *
   * @type {number}
   * @memberof RoomDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof RoomDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof RoomDto
   */
  capacity?: number;
  /**
   *
   * @type {number}
   * @memberof RoomDto
   */
  totalArea?: number;
  /**
   *
   * @type {string}
   * @memberof RoomDto
   */
  imgURL?: string;
}
/**
 *
 * @export
 * @interface ScheduleDto
 */
export interface ScheduleDto {
  /**
   *
   * @type {number}
   * @memberof ScheduleDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ScheduleDto
   */
  startDate?: string;
  /**
   *
   * @type {LocalTime}
   * @memberof ScheduleDto
   */
  startTime?: LocalTime;
  /**
   *
   * @type {BranchDto}
   * @memberof ScheduleDto
   */
  branch?: BranchDto;
  /**
   *
   * @type {RoomDto}
   * @memberof ScheduleDto
   */
  room?: RoomDto;
  /**
   *
   * @type {MovieDto}
   * @memberof ScheduleDto
   */
  movie?: MovieDto;
  /**
   *
   * @type {number}
   * @memberof ScheduleDto
   */
  price?: number;
}
/**
 *
 * @export
 * @interface SeatDto
 */
export interface SeatDto {
  /**
   *
   * @type {number}
   * @memberof SeatDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof SeatDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof SeatDto
   */
  type?: SeatDto.TypeEnum;
  /**
   *
   * @type {number}
   * @memberof SeatDto
   */
  isOccupied?: number;
}

/**
 * @export
 * @namespace SeatDto
 */
export namespace SeatDto {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    NORMAL = <any>"NORMAL",
    VIP = <any>"VIP",
  }
}
/**
 *
 * @export
 * @interface SendContentCreatorRequest
 */
export interface SendContentCreatorRequest {
  /**
   *
   * @type {string}
   * @memberof SendContentCreatorRequest
   */
  reason?: string;
  /**
   *
   * @type {number}
   * @memberof SendContentCreatorRequest
   */
  userId: number;
}
/**
 *
 * @export
 * @interface SignUpRequest
 */
export interface SignUpRequest {
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  username: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  email: string;
  /**
   *
   * @type {string}
   * @memberof SignUpRequest
   */
  password: string;
}
/**
 *
 * @export
 * @interface TicketDto
 */
export interface TicketDto {
  /**
   *
   * @type {number}
   * @memberof TicketDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof TicketDto
   */
  qrImageURL?: string;
  /**
   *
   * @type {ScheduleDto}
   * @memberof TicketDto
   */
  schedule?: ScheduleDto;
  /**
   *
   * @type {SeatDto}
   * @memberof TicketDto
   */
  seat?: SeatDto;
  /**
   *
   * @type {BillDto}
   * @memberof TicketDto
   */
  bill?: BillDto;
}
/**
 *
 * @export
 * @interface TransactionReportSuccess
 */
export interface TransactionReportSuccess {
  /**
   *
   * @type {string}
   * @memberof TransactionReportSuccess
   */
  date?: string;
  /**
   *
   * @type {number}
   * @memberof TransactionReportSuccess
   */
  userId?: number;
  /**
   *
   * @type {number}
   * @memberof TransactionReportSuccess
   */
  amountTransaction?: number;
  /**
   *
   * @type {number}
   * @memberof TransactionReportSuccess
   */
  precipitation?: number;
}
/**
 *
 * @export
 * @interface UpdateArticleRequest
 */
export interface UpdateArticleRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateArticleRequest
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  mainImage?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  brief?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  thumbnail?: string;
  /**
   *
   * @type {number}
   * @memberof UpdateArticleRequest
   */
  categoryId?: number;
  /**
   *
   * @type {string}
   * @memberof UpdateArticleRequest
   */
  keyword?: string;
}
/**
 *
 * @export
 * @interface UpdateCategoryRequest
 */
export interface UpdateCategoryRequest {
  /**
   *
   * @type {Array<number>}
   * @memberof UpdateCategoryRequest
   */
  categories?: Array<number>;
  /**
   *
   * @type {number}
   * @memberof UpdateCategoryRequest
   */
  userId: number;
}
/**
 *
 * @export
 * @interface UpdateCommentRequest
 */
export interface UpdateCommentRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateCommentRequest
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateCommentRequest
   */
  description?: string;
}
/**
 *
 * @export
 * @interface UpdateMovieRequest
 */
export interface UpdateMovieRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateMovieRequest
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  name: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  smallImageURl?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  shortDescription?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  longDescription?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  largeImageURL?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  director: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  actors: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  categories: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  releaseDate: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMovieRequest
   */
  duration: number;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  trailerURL?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  language?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateMovieRequest
   */
  rated: string;
  /**
   *
   * @type {number}
   * @memberof UpdateMovieRequest
   */
  isShowing: number;
}
/**
 *
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
  /**
   *
   * @type {number}
   * @memberof UpdateUserRequest
   */
  id: number;
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof UpdateUserRequest
   */
  bio?: string;
}
/**
 *
 * @export
 * @interface UserDto
 */
export interface UserDto {
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  role?: string;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  bio?: string;
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  followers?: number;
  /**
   *
   * @type {Array<CategoryDto>}
   * @memberof UserDto
   */
  categories?: Array<CategoryDto>;
  /**
   *
   * @type {number}
   * @memberof UserDto
   */
  amountArticle?: number;
  /**
   *
   * @type {string}
   * @memberof UserDto
   */
  reason?: string;
  /**
   *
   * @type {boolean}
   * @memberof UserDto
   */
  contentCreator?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserDto
   */
  _new?: boolean;
}
/**
 *
 * @export
 * @interface UserIdentityAvailability
 */
export interface UserIdentityAvailability {
  /**
   *
   * @type {boolean}
   * @memberof UserIdentityAvailability
   */
  available?: boolean;
}
/**
 *
 * @export
 * @interface UserPrincipal
 */
export interface UserPrincipal {
  /**
   *
   * @type {number}
   * @memberof UserPrincipal
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserPrincipal
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserPrincipal
   */
  username?: string;
  /**
   *
   * @type {Array<GrantedAuthority>}
   * @memberof UserPrincipal
   */
  authorities?: Array<GrantedAuthority>;
  /**
   *
   * @type {boolean}
   * @memberof UserPrincipal
   */
  enabled?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserPrincipal
   */
  accountNonLocked?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserPrincipal
   */
  accountNonExpired?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof UserPrincipal
   */
  credentialsNonExpired?: boolean;
}
/**
 *
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
  /**
   *
   * @type {number}
   * @memberof UserProfile
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserProfile
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserProfile
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserProfile
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserProfile
   */
  image?: string;
}
/**
 *
 * @export
 * @interface UserReportDto
 */
export interface UserReportDto {
  /**
   *
   * @type {string}
   * @memberof UserReportDto
   */
  image?: string;
  /**
   *
   * @type {number}
   * @memberof UserReportDto
   */
  transactionCount?: number;
  /**
   *
   * @type {number}
   * @memberof UserReportDto
   */
  incomeAmount?: number;
  /**
   *
   * @type {number}
   * @memberof UserReportDto
   */
  ticketAmount?: number;
  /**
   *
   * @type {string}
   * @memberof UserReportDto
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserReportDto
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserReportDto
   */
  name?: string;
  /**
   *
   * @type {number}
   * @memberof UserReportDto
   */
  id?: number;
}
/**
 *
 * @export
 * @interface UserSummary
 */
export interface UserSummary {
  /**
   *
   * @type {number}
   * @memberof UserSummary
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof UserSummary
   */
  username?: string;
  /**
   *
   * @type {string}
   * @memberof UserSummary
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof UserSummary
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof UserSummary
   */
  image?: string;
  /**
   *
   * @type {string}
   * @memberof UserSummary
   */
  role?: string;
}
/**
 * ArticleControllerApi - fetch parameter creator
 * @export
 */
export const ArticleControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Thêm mới Category
     * @summary Thêm mới Category
     * @param {string} [categoryName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCategory(categoryName?: string, options: any = {}): FetchArgs {
      const localVarPath = `/api/article/category/add`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (categoryName !== undefined) {
        localVarQueryParameter["categoryName"] = categoryName;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm mới bai viet của User
     * @summary Thêm mới Draft bản nháp co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleDraft(body: AddNewArRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewArticleDraft."
        );
      }
      const localVarPath = `/api/article/addNewDraft`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewArRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm mới bai viet của User
     * @summary [NEWS WEBSITE] Thêm mới bai viet co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNEWS(body: AddNewArRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewArticleNEWS."
        );
      }
      const localVarPath = `/api/article/addNewArticle`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewArRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @summary Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @param {AddNewArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNew(body: AddNewArticleRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewArticleNew."
        );
      }
      const localVarPath = `/api/article/addNew`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewArticleRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm mới Review của User
     * @summary Thêm mới Review của User
     * @param {AddNewReviewRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleReview(
      body: AddNewReviewRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewArticleReview."
        );
      }
      const localVarPath = `/api/article/addNewReview`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewReviewRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm bài viết lưu trữ ( yêu thích) của user
     * @summary Thêm bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleinUser(
      userId: number,
      articleId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling addNewArticleinUser."
        );
      }
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling addNewArticleinUser."
        );
      }
      const localVarPath = `/api/article/user/addSaveArticle`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (articleId !== undefined) {
        localVarQueryParameter["articleId"] = articleId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Chuyển từ bản nháp sang bản chính thức bài viết
     * @summary Chuyển từ bản nháp sang bản chính thức bài viết
     * @param {number} draftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewDraftPublic(draftId: number, options: any = {}): FetchArgs {
      // verify required parameter 'draftId' is not null or undefined
      if (draftId === null || draftId === undefined) {
        throw new RequiredError(
          "draftId",
          "Required parameter draftId was null or undefined when calling addNewDraftPublic."
        );
      }
      const localVarPath = `/api/article/publicDraft`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (draftId !== undefined) {
        localVarQueryParameter["draftId"] = draftId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Chỉnh sửa trạng thái của Article
     * @summary Chỉnh sửa trạng thái của Article
     * @param {number} articleId
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeStatusArticle(
      articleId: number,
      status: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling changeStatusArticle."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling changeStatusArticle."
        );
      }
      const localVarPath = `/api/article/changeStatus`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (articleId !== undefined) {
        localVarQueryParameter["articleId"] = articleId;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Article với filter
     * @summary Get All Article với filter
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticle(
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/article/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      if (listCategory) {
        localVarQueryParameter["listCategory"] = listCategory;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (articleType !== undefined) {
        localVarQueryParameter["articleType"] = articleType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/article/getAllPaging`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      if (listCategory) {
        localVarQueryParameter["listCategory"] = listCategory;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (articleType !== undefined) {
        localVarQueryParameter["articleType"] = articleType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePagingV2(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/article/v2/getAllPaging`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (title !== undefined) {
        localVarQueryParameter["title"] = title;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (keyword !== undefined) {
        localVarQueryParameter["keyword"] = keyword;
      }

      if (listCategory) {
        localVarQueryParameter["listCategory"] = listCategory;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (articleType !== undefined) {
        localVarQueryParameter["articleType"] = articleType;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get All Category
     * @summary Get All Category
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCate(name?: string, options: any = {}): FetchArgs {
      const localVarPath = `/api/article/category/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get All Category lưu trữ( yêu thích của user)
     * @summary Get All Category lưu trữ( yêu thích của user)
     * @param {number} userId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser(
      userId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling getAllCateByUser."
        );
      }
      const localVarPath = `/api/article/user/saveArticle/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get All Category For User
     * @summary Get All Category For User
     * @param {UserPrincipal} currentUser
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser1(
      currentUser: UserPrincipal,
      status: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'currentUser' is not null or undefined
      if (currentUser === null || currentUser === undefined) {
        throw new RequiredError(
          "currentUser",
          "Required parameter currentUser was null or undefined when calling getAllCateByUser1."
        );
      }
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling getAllCateByUser1."
        );
      }
      const localVarPath = `/api/article/user/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (currentUser !== undefined) {
        localVarQueryParameter["currentUser"] = currentUser;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get Detail Article
     * @summary Get Detail Article
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetail(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getDetail."
        );
      }
      const localVarPath = `/api/article/getDetail`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get Detail Article by (slug)
     * @summary Get Detail Article by ( slug)
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailByTitle(slug: string, options: any = {}): FetchArgs {
      // verify required parameter 'slug' is not null or undefined
      if (slug === null || slug === undefined) {
        throw new RequiredError(
          "slug",
          "Required parameter slug was null or undefined when calling getDetailByTitle."
        );
      }
      const localVarPath = `/api/article/getDetail/{slug}`.replace(
        `{${"slug"}}`,
        encodeURIComponent(String(slug))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Report user and article
     * @summary Get Report user and article
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUser(dateTime: string, options: any = {}): FetchArgs {
      // verify required parameter 'dateTime' is not null or undefined
      if (dateTime === null || dateTime === undefined) {
        throw new RequiredError(
          "dateTime",
          "Required parameter dateTime was null or undefined when calling getReportUser."
        );
      }
      const localVarPath = `/api/article/user/getAllReport`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (dateTime !== undefined) {
        localVarQueryParameter["dateTime"] = dateTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Gỡ bài viết lưu trữ ( yêu thích) của user
     * @summary Gỡ bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeArticleinUser(
      userId: number,
      articleId: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling removeArticleinUser."
        );
      }
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling removeArticleinUser."
        );
      }
      const localVarPath = `/api/article/user/removeSaveArticle`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (articleId !== undefined) {
        localVarQueryParameter["articleId"] = articleId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Xoá Category không được sử dụng(cate đang được sử dụng không được xóa)
     * @summary Xoá Category không được sử dụng
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCategory(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling removeCategory."
        );
      }
      const localVarPath = `/api/article/category/delete/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Chỉnh sửa Article
     * @summary Chỉnh sửa Article
     * @param {UpdateArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(body: UpdateArticleRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateArticle."
        );
      }
      const localVarPath = `/api/article/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateArticleRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ArticleControllerApi - functional programming interface
 * @export
 */
export const ArticleControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Thêm mới Category
     * @summary Thêm mới Category
     * @param {string} [categoryName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCategory(
      categoryName?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseCategoryDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addCategory(categoryName, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm mới bai viet của User
     * @summary Thêm mới Draft bản nháp co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleDraft(
      body: AddNewArRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewArticleDraft(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm mới bai viet của User
     * @summary [NEWS WEBSITE] Thêm mới bai viet co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNEWS(
      body: AddNewArRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewArticleNEWS(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @summary Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @param {AddNewArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNew(
      body: AddNewArticleRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewArticleNew(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm mới Review của User
     * @summary Thêm mới Review của User
     * @param {AddNewReviewRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleReview(
      body: AddNewReviewRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewArticleReview(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm bài viết lưu trữ ( yêu thích) của user
     * @summary Thêm bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleinUser(
      userId: number,
      articleId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewArticleinUser(userId, articleId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Chuyển từ bản nháp sang bản chính thức bài viết
     * @summary Chuyển từ bản nháp sang bản chính thức bài viết
     * @param {number} draftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewDraftPublic(
      draftId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).addNewDraftPublic(draftId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Chỉnh sửa trạng thái của Article
     * @summary Chỉnh sửa trạng thái của Article
     * @param {number} articleId
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeStatusArticle(
      articleId: number,
      status: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).changeStatusArticle(articleId, status, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Article với filter
     * @summary Get All Article với filter
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticle(
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).findAllArticle(
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).findAllArticlePaging(
        page,
        size,
        sort,
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePagingV2(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).findAllArticlePagingV2(
        page,
        size,
        sort,
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get All Category
     * @summary Get All Category
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCate(
      name?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListCategoryDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getAllCate(name, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get All Category lưu trữ( yêu thích của user)
     * @summary Get All Category lưu trữ( yêu thích của user)
     * @param {number} userId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser(
      userId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getAllCateByUser(userId, page, size, sort, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get All Category For User
     * @summary Get All Category For User
     * @param {UserPrincipal} currentUser
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser1(
      currentUser: UserPrincipal,
      status: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getAllCateByUser1(currentUser, status, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get Detail Article
     * @summary Get Detail Article
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetail(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getDetail(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get Detail Article by (slug)
     * @summary Get Detail Article by ( slug)
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailByTitle(
      slug: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getDetailByTitle(slug, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Get Report user and article
     * @summary Get Report user and article
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUser(
      dateTime: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleReportDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).getReportUser(dateTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Gỡ bài viết lưu trữ ( yêu thích) của user
     * @summary Gỡ bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeArticleinUser(
      userId: number,
      articleId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).removeArticleinUser(userId, articleId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Xoá Category không được sử dụng(cate đang được sử dụng không được xóa)
     * @summary Xoá Category không được sử dụng
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCategory(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).removeCategory(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Chỉnh sửa Article
     * @summary Chỉnh sửa Article
     * @param {UpdateArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(
      body: UpdateArticleRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseArticleDto> {
      const localVarFetchArgs = ArticleControllerApiFetchParamCreator(
        configuration
      ).updateArticle(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ArticleControllerApi - factory interface
 * @export
 */
export const ArticleControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Thêm mới Category
     * @summary Thêm mới Category
     * @param {string} [categoryName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCategory(categoryName?: string, options?: any) {
      return ArticleControllerApiFp(configuration).addCategory(
        categoryName,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm mới bai viet của User
     * @summary Thêm mới Draft bản nháp co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleDraft(body: AddNewArRequest, options?: any) {
      return ArticleControllerApiFp(configuration).addNewArticleDraft(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm mới bai viet của User
     * @summary [NEWS WEBSITE] Thêm mới bai viet co cate của User
     * @param {AddNewArRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNEWS(body: AddNewArRequest, options?: any) {
      return ArticleControllerApiFp(configuration).addNewArticleNEWS(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @summary Thêm mới tin tức, sự kiện khuyến mãi của Staff
     * @param {AddNewArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleNew(body: AddNewArticleRequest, options?: any) {
      return ArticleControllerApiFp(configuration).addNewArticleNew(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm mới Review của User
     * @summary Thêm mới Review của User
     * @param {AddNewReviewRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleReview(body: AddNewReviewRequest, options?: any) {
      return ArticleControllerApiFp(configuration).addNewArticleReview(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm bài viết lưu trữ ( yêu thích) của user
     * @summary Thêm bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewArticleinUser(userId: number, articleId: number, options?: any) {
      return ArticleControllerApiFp(configuration).addNewArticleinUser(
        userId,
        articleId,
        options
      )(fetch, basePath);
    },
    /**
     * - Chuyển từ bản nháp sang bản chính thức bài viết
     * @summary Chuyển từ bản nháp sang bản chính thức bài viết
     * @param {number} draftId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewDraftPublic(draftId: number, options?: any) {
      return ArticleControllerApiFp(configuration).addNewDraftPublic(
        draftId,
        options
      )(fetch, basePath);
    },
    /**
     * - Chỉnh sửa trạng thái của Article
     * @summary Chỉnh sửa trạng thái của Article
     * @param {number} articleId
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeStatusArticle(articleId: number, status: string, options?: any) {
      return ArticleControllerApiFp(configuration).changeStatusArticle(
        articleId,
        status,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Article với filter
     * @summary Get All Article với filter
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticle(
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ) {
      return ArticleControllerApiFp(configuration).findAllArticle(
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ) {
      return ArticleControllerApiFp(configuration).findAllArticlePaging(
        page,
        size,
        sort,
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Article với filter và paging
     * @summary Get All Article với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [title]
     * @param {string} [status]
     * @param {string} [keyword]
     * @param {Array<string>} [listCategory]
     * @param {string} [username]
     * @param {string} [articleType]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllArticlePagingV2(
      page?: number,
      size?: number,
      sort?: Array<string>,
      title?: string,
      status?: string,
      keyword?: string,
      listCategory?: Array<string>,
      username?: string,
      articleType?: string,
      options?: any
    ) {
      return ArticleControllerApiFp(configuration).findAllArticlePagingV2(
        page,
        size,
        sort,
        title,
        status,
        keyword,
        listCategory,
        username,
        articleType,
        options
      )(fetch, basePath);
    },
    /**
     * Get All Category
     * @summary Get All Category
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCate(name?: string, options?: any) {
      return ArticleControllerApiFp(configuration).getAllCate(name, options)(
        fetch,
        basePath
      );
    },
    /**
     * Get All Category lưu trữ( yêu thích của user)
     * @summary Get All Category lưu trữ( yêu thích của user)
     * @param {number} userId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser(
      userId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ) {
      return ArticleControllerApiFp(configuration).getAllCateByUser(
        userId,
        page,
        size,
        sort,
        options
      )(fetch, basePath);
    },
    /**
     * Get All Category For User
     * @summary Get All Category For User
     * @param {UserPrincipal} currentUser
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllCateByUser1(
      currentUser: UserPrincipal,
      status: string,
      options?: any
    ) {
      return ArticleControllerApiFp(configuration).getAllCateByUser1(
        currentUser,
        status,
        options
      )(fetch, basePath);
    },
    /**
     * - Get Detail Article
     * @summary Get Detail Article
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetail(id: number, options?: any) {
      return ArticleControllerApiFp(configuration).getDetail(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Get Detail Article by (slug)
     * @summary Get Detail Article by ( slug)
     * @param {string} slug
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDetailByTitle(slug: string, options?: any) {
      return ArticleControllerApiFp(configuration).getDetailByTitle(
        slug,
        options
      )(fetch, basePath);
    },
    /**
     * Get Report user and article
     * @summary Get Report user and article
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getReportUser(dateTime: string, options?: any) {
      return ArticleControllerApiFp(configuration).getReportUser(
        dateTime,
        options
      )(fetch, basePath);
    },
    /**
     * - Gỡ bài viết lưu trữ ( yêu thích) của user
     * @summary Gỡ bài viết lưu trữ ( yêu thích) của user
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeArticleinUser(userId: number, articleId: number, options?: any) {
      return ArticleControllerApiFp(configuration).removeArticleinUser(
        userId,
        articleId,
        options
      )(fetch, basePath);
    },
    /**
     * Xoá Category không được sử dụng(cate đang được sử dụng không được xóa)
     * @summary Xoá Category không được sử dụng
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCategory(id: number, options?: any) {
      return ArticleControllerApiFp(configuration).removeCategory(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Chỉnh sửa Article
     * @summary Chỉnh sửa Article
     * @param {UpdateArticleRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateArticle(body: UpdateArticleRequest, options?: any) {
      return ArticleControllerApiFp(configuration).updateArticle(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * ArticleControllerApi - object-oriented interface
 * @export
 * @class ArticleControllerApi
 * @extends {BaseAPI}
 */
export class ArticleControllerApi extends BaseAPI {
  /**
   * Thêm mới Category
   * @summary Thêm mới Category
   * @param {string} [categoryName]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addCategory(categoryName?: string, options?: any) {
    return ArticleControllerApiFp(this.configuration).addCategory(
      categoryName,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm mới bai viet của User
   * @summary Thêm mới Draft bản nháp co cate của User
   * @param {AddNewArRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewArticleDraft(body: AddNewArRequest, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewArticleDraft(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm mới bai viet của User
   * @summary [NEWS WEBSITE] Thêm mới bai viet co cate của User
   * @param {AddNewArRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewArticleNEWS(body: AddNewArRequest, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewArticleNEWS(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm mới tin tức, sự kiện khuyến mãi của Staff
   * @summary Thêm mới tin tức, sự kiện khuyến mãi của Staff
   * @param {AddNewArticleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewArticleNew(body: AddNewArticleRequest, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewArticleNew(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm mới Review của User
   * @summary Thêm mới Review của User
   * @param {AddNewReviewRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewArticleReview(body: AddNewReviewRequest, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewArticleReview(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm bài viết lưu trữ ( yêu thích) của user
   * @summary Thêm bài viết lưu trữ ( yêu thích) của user
   * @param {number} userId
   * @param {number} articleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewArticleinUser(userId: number, articleId: number, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewArticleinUser(
      userId,
      articleId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Chuyển từ bản nháp sang bản chính thức bài viết
   * @summary Chuyển từ bản nháp sang bản chính thức bài viết
   * @param {number} draftId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public addNewDraftPublic(draftId: number, options?: any) {
    return ArticleControllerApiFp(this.configuration).addNewDraftPublic(
      draftId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Chỉnh sửa trạng thái của Article
   * @summary Chỉnh sửa trạng thái của Article
   * @param {number} articleId
   * @param {string} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public changeStatusArticle(articleId: number, status: string, options?: any) {
    return ArticleControllerApiFp(this.configuration).changeStatusArticle(
      articleId,
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Article với filter
   * @summary Get All Article với filter
   * @param {string} [title]
   * @param {string} [status]
   * @param {string} [keyword]
   * @param {Array<string>} [listCategory]
   * @param {string} [username]
   * @param {string} [articleType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public findAllArticle(
    title?: string,
    status?: string,
    keyword?: string,
    listCategory?: Array<string>,
    username?: string,
    articleType?: string,
    options?: any
  ) {
    return ArticleControllerApiFp(this.configuration).findAllArticle(
      title,
      status,
      keyword,
      listCategory,
      username,
      articleType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Article với filter và paging
   * @summary Get All Article với filter và paging
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [title]
   * @param {string} [status]
   * @param {string} [keyword]
   * @param {Array<string>} [listCategory]
   * @param {string} [username]
   * @param {string} [articleType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public findAllArticlePaging(
    page?: number,
    size?: number,
    sort?: Array<string>,
    title?: string,
    status?: string,
    keyword?: string,
    listCategory?: Array<string>,
    username?: string,
    articleType?: string,
    options?: any
  ) {
    return ArticleControllerApiFp(this.configuration).findAllArticlePaging(
      page,
      size,
      sort,
      title,
      status,
      keyword,
      listCategory,
      username,
      articleType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Article với filter và paging
   * @summary Get All Article với filter và paging
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [title]
   * @param {string} [status]
   * @param {string} [keyword]
   * @param {Array<string>} [listCategory]
   * @param {string} [username]
   * @param {string} [articleType]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public findAllArticlePagingV2(
    page?: number,
    size?: number,
    sort?: Array<string>,
    title?: string,
    status?: string,
    keyword?: string,
    listCategory?: Array<string>,
    username?: string,
    articleType?: string,
    options?: any
  ) {
    return ArticleControllerApiFp(this.configuration).findAllArticlePagingV2(
      page,
      size,
      sort,
      title,
      status,
      keyword,
      listCategory,
      username,
      articleType,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Get All Category
   * @summary Get All Category
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getAllCate(name?: string, options?: any) {
    return ArticleControllerApiFp(this.configuration).getAllCate(name, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Get All Category lưu trữ( yêu thích của user)
   * @summary Get All Category lưu trữ( yêu thích của user)
   * @param {number} userId
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getAllCateByUser(
    userId: number,
    page?: number,
    size?: number,
    sort?: Array<string>,
    options?: any
  ) {
    return ArticleControllerApiFp(this.configuration).getAllCateByUser(
      userId,
      page,
      size,
      sort,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Get All Category For User
   * @summary Get All Category For User
   * @param {UserPrincipal} currentUser
   * @param {string} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getAllCateByUser1(
    currentUser: UserPrincipal,
    status: string,
    options?: any
  ) {
    return ArticleControllerApiFp(this.configuration).getAllCateByUser1(
      currentUser,
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get Detail Article
   * @summary Get Detail Article
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getDetail(id: number, options?: any) {
    return ArticleControllerApiFp(this.configuration).getDetail(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * - Get Detail Article by (slug)
   * @summary Get Detail Article by ( slug)
   * @param {string} slug
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getDetailByTitle(slug: string, options?: any) {
    return ArticleControllerApiFp(this.configuration).getDetailByTitle(
      slug,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Get Report user and article
   * @summary Get Report user and article
   * @param {string} dateTime
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public getReportUser(dateTime: string, options?: any) {
    return ArticleControllerApiFp(this.configuration).getReportUser(
      dateTime,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Gỡ bài viết lưu trữ ( yêu thích) của user
   * @summary Gỡ bài viết lưu trữ ( yêu thích) của user
   * @param {number} userId
   * @param {number} articleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public removeArticleinUser(userId: number, articleId: number, options?: any) {
    return ArticleControllerApiFp(this.configuration).removeArticleinUser(
      userId,
      articleId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Xoá Category không được sử dụng(cate đang được sử dụng không được xóa)
   * @summary Xoá Category không được sử dụng
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public removeCategory(id: number, options?: any) {
    return ArticleControllerApiFp(this.configuration).removeCategory(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Chỉnh sửa Article
   * @summary Chỉnh sửa Article
   * @param {UpdateArticleRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ArticleControllerApi
   */
  public updateArticle(body: UpdateArticleRequest, options?: any) {
    return ArticleControllerApiFp(this.configuration).updateArticle(
      body,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * AuthControllerApi - fetch parameter creator
 * @export
 */
export const AuthControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateUser(body: LoginRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling authenticateUser."
        );
      }
      const localVarPath = `/api/auth/signin`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"LoginRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} newPassword
     * @param {string} oldPassword
     * @param {UserPrincipal} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      newPassword: string,
      oldPassword: string,
      body?: UserPrincipal,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'newPassword' is not null or undefined
      if (newPassword === null || newPassword === undefined) {
        throw new RequiredError(
          "newPassword",
          "Required parameter newPassword was null or undefined when calling changePassword."
        );
      }
      // verify required parameter 'oldPassword' is not null or undefined
      if (oldPassword === null || oldPassword === undefined) {
        throw new RequiredError(
          "oldPassword",
          "Required parameter oldPassword was null or undefined when calling changePassword."
        );
      }
      const localVarPath = `/api/auth/changePassword`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (newPassword !== undefined) {
        localVarQueryParameter["newPassword"] = newPassword;
      }

      if (oldPassword !== undefined) {
        localVarQueryParameter["oldPassword"] = oldPassword;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UserPrincipal" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStaff(body: SignUpRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling registerStaff."
        );
      }
      const localVarPath = `/api/auth/registerStaff`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SignUpRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(body: SignUpRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling registerUser."
        );
      }
      const localVarPath = `/api/auth/signup`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SignUpRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateUser(
      body: LoginRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AuthControllerApiFetchParamCreator(
        configuration
      ).authenticateUser(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} newPassword
     * @param {string} oldPassword
     * @param {UserPrincipal} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      newPassword: string,
      oldPassword: string,
      body?: UserPrincipal,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AuthControllerApiFetchParamCreator(
        configuration
      ).changePassword(newPassword, oldPassword, body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStaff(
      body: SignUpRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AuthControllerApiFetchParamCreator(
        configuration
      ).registerStaff(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(
      body: SignUpRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
      const localVarFetchArgs = AuthControllerApiFetchParamCreator(
        configuration
      ).registerUser(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {LoginRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    authenticateUser(body: LoginRequest, options?: any) {
      return AuthControllerApiFp(configuration).authenticateUser(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} newPassword
     * @param {string} oldPassword
     * @param {UserPrincipal} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      newPassword: string,
      oldPassword: string,
      body?: UserPrincipal,
      options?: any
    ) {
      return AuthControllerApiFp(configuration).changePassword(
        newPassword,
        oldPassword,
        body,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerStaff(body: SignUpRequest, options?: any) {
      return AuthControllerApiFp(configuration).registerStaff(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {SignUpRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerUser(body: SignUpRequest, options?: any) {
      return AuthControllerApiFp(configuration).registerUser(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
  /**
   *
   * @param {LoginRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public authenticateUser(body: LoginRequest, options?: any) {
    return AuthControllerApiFp(this.configuration).authenticateUser(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} newPassword
   * @param {string} oldPassword
   * @param {UserPrincipal} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public changePassword(
    newPassword: string,
    oldPassword: string,
    body?: UserPrincipal,
    options?: any
  ) {
    return AuthControllerApiFp(this.configuration).changePassword(
      newPassword,
      oldPassword,
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {SignUpRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public registerStaff(body: SignUpRequest, options?: any) {
    return AuthControllerApiFp(this.configuration).registerStaff(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {SignUpRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AuthControllerApi
   */
  public registerUser(body: SignUpRequest, options?: any) {
    return AuthControllerApiFp(this.configuration).registerUser(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * BillControllerApi - fetch parameter creator
 * @export
 */
export const BillControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Tạo hóa đơn
     * @summary Tạo hóa đơn
     * @param {BookingRequestDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewBill(body: BookingRequestDto, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNewBill."
        );
      }
      const localVarPath = `/api/bills/create-new-bill`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"BookingRequestDto" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy thống kê giao dịch thành công
     * @summary Lấy thống kê giao dịch thành công
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard(dateTime: string, options: any = {}): FetchArgs {
      // verify required parameter 'dateTime' is not null or undefined
      if (dateTime === null || dateTime === undefined) {
        throw new RequiredError(
          "dateTime",
          "Required parameter dateTime was null or undefined when calling getBillDashBoard."
        );
      }
      const localVarPath = `/api/bills/getBillSuccess`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (dateTime !== undefined) {
        localVarQueryParameter["dateTime"] = dateTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy DashBoard Bill
     * @summary Lấy DashBoard Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard1(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/bills/getBillDashBoard`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (fromDate !== undefined) {
        localVarQueryParameter["fromDate"] = fromDate;
      }

      if (toDate !== undefined) {
        localVarQueryParameter["toDate"] = toDate;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy Danh sach Bill
     * @summary Lấy Danh sach Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getList(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/bills/getAllBill`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (fromDate !== undefined) {
        localVarQueryParameter["fromDate"] = fromDate;
      }

      if (toDate !== undefined) {
        localVarQueryParameter["toDate"] = toDate;
      }

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy DashBoard User
     * @summary Lấy DashBoard User
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDashBoard(status: string, options: any = {}): FetchArgs {
      // verify required parameter 'status' is not null or undefined
      if (status === null || status === undefined) {
        throw new RequiredError(
          "status",
          "Required parameter status was null or undefined when calling getUserDashBoard."
        );
      }
      const localVarPath = `/api/bills/getUserDashBoard`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (status !== undefined) {
        localVarQueryParameter["status"] = status;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thanh toan hóa đơn
     * @summary Thanh toan hóa đơn
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    payBill(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling payBill."
        );
      }
      const localVarPath = `/api/bills/payment`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Tạo hóa đơn
     * @summary Huy hóa đơn
     * @param {number} [billId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    xoaNewBill(billId?: number, options: any = {}): FetchArgs {
      const localVarPath = `/api/bills/delete`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (billId !== undefined) {
        localVarQueryParameter["billId"] = billId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BillControllerApi - functional programming interface
 * @export
 */
export const BillControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * - Tạo hóa đơn
     * @summary Tạo hóa đơn
     * @param {BookingRequestDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewBill(
      body: BookingRequestDto,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseBillDto> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).createNewBill(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy thống kê giao dịch thành công
     * @summary Lấy thống kê giao dịch thành công
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard(
      dateTime: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<Array<TransactionReportSuccess>> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).getBillDashBoard(dateTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy DashBoard Bill
     * @summary Lấy DashBoard Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard1(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GetDashboardTransactionResponse> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).getBillDashBoard1(fromDate, toDate, status, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy Danh sach Bill
     * @summary Lấy Danh sach Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getList(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BillDto>> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).getList(fromDate, toDate, status, userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy DashBoard User
     * @summary Lấy DashBoard User
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDashBoard(
      status: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserReportDto>> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).getUserDashBoard(status, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thanh toan hóa đơn
     * @summary Thanh toan hóa đơn
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    payBill(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BillDto> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).payBill(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Tạo hóa đơn
     * @summary Huy hóa đơn
     * @param {number} [billId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    xoaNewBill(
      billId?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
      const localVarFetchArgs = BillControllerApiFetchParamCreator(
        configuration
      ).xoaNewBill(billId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * BillControllerApi - factory interface
 * @export
 */
export const BillControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * - Tạo hóa đơn
     * @summary Tạo hóa đơn
     * @param {BookingRequestDto} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewBill(body: BookingRequestDto, options?: any) {
      return BillControllerApiFp(configuration).createNewBill(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Lấy thống kê giao dịch thành công
     * @summary Lấy thống kê giao dịch thành công
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard(dateTime: string, options?: any) {
      return BillControllerApiFp(configuration).getBillDashBoard(
        dateTime,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy DashBoard Bill
     * @summary Lấy DashBoard Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBillDashBoard1(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options?: any
    ) {
      return BillControllerApiFp(configuration).getBillDashBoard1(
        fromDate,
        toDate,
        status,
        userId,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy Danh sach Bill
     * @summary Lấy Danh sach Bill
     * @param {string} [fromDate]
     * @param {string} [toDate]
     * @param {string} [status]
     * @param {number} [userId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getList(
      fromDate?: string,
      toDate?: string,
      status?: string,
      userId?: number,
      options?: any
    ) {
      return BillControllerApiFp(configuration).getList(
        fromDate,
        toDate,
        status,
        userId,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy DashBoard User
     * @summary Lấy DashBoard User
     * @param {string} status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserDashBoard(status: string, options?: any) {
      return BillControllerApiFp(configuration).getUserDashBoard(
        status,
        options
      )(fetch, basePath);
    },
    /**
     * - Thanh toan hóa đơn
     * @summary Thanh toan hóa đơn
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    payBill(id: number, options?: any) {
      return BillControllerApiFp(configuration).payBill(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Tạo hóa đơn
     * @summary Huy hóa đơn
     * @param {number} [billId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    xoaNewBill(billId?: number, options?: any) {
      return BillControllerApiFp(configuration).xoaNewBill(billId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * BillControllerApi - object-oriented interface
 * @export
 * @class BillControllerApi
 * @extends {BaseAPI}
 */
export class BillControllerApi extends BaseAPI {
  /**
   * - Tạo hóa đơn
   * @summary Tạo hóa đơn
   * @param {BookingRequestDto} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public createNewBill(body: BookingRequestDto, options?: any) {
    return BillControllerApiFp(this.configuration).createNewBill(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * - Lấy thống kê giao dịch thành công
   * @summary Lấy thống kê giao dịch thành công
   * @param {string} dateTime
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public getBillDashBoard(dateTime: string, options?: any) {
    return BillControllerApiFp(this.configuration).getBillDashBoard(
      dateTime,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy DashBoard Bill
   * @summary Lấy DashBoard Bill
   * @param {string} [fromDate]
   * @param {string} [toDate]
   * @param {string} [status]
   * @param {number} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public getBillDashBoard1(
    fromDate?: string,
    toDate?: string,
    status?: string,
    userId?: number,
    options?: any
  ) {
    return BillControllerApiFp(this.configuration).getBillDashBoard1(
      fromDate,
      toDate,
      status,
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy Danh sach Bill
   * @summary Lấy Danh sach Bill
   * @param {string} [fromDate]
   * @param {string} [toDate]
   * @param {string} [status]
   * @param {number} [userId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public getList(
    fromDate?: string,
    toDate?: string,
    status?: string,
    userId?: number,
    options?: any
  ) {
    return BillControllerApiFp(this.configuration).getList(
      fromDate,
      toDate,
      status,
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy DashBoard User
   * @summary Lấy DashBoard User
   * @param {string} status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public getUserDashBoard(status: string, options?: any) {
    return BillControllerApiFp(this.configuration).getUserDashBoard(
      status,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thanh toan hóa đơn
   * @summary Thanh toan hóa đơn
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public payBill(id: number, options?: any) {
    return BillControllerApiFp(this.configuration).payBill(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * - Tạo hóa đơn
   * @summary Huy hóa đơn
   * @param {number} [billId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BillControllerApi
   */
  public xoaNewBill(billId?: number, options?: any) {
    return BillControllerApiFp(this.configuration).xoaNewBill(billId, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * BranchControllerApi - fetch parameter creator
 * @export
 */
export const BranchControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Get All Branch với filter
     * @summary Get All Branch với filter
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch(
      name?: string,
      address?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/branches/getList`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (address !== undefined) {
        localVarQueryParameter["address"] = address;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Branch với filter paging
     * @summary Get All Branch với filter  paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      name?: string,
      address?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/branches/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (address !== undefined) {
        localVarQueryParameter["address"] = address;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Branch
     * @summary Get Detail Branch
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchDetail(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling getBranchDetail."
        );
      }
      const localVarPath = `/api/branches/getDetail`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchesThatShowTheMovie(movieId: number, options: any = {}): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling getBranchesThatShowTheMovie."
        );
      }
      const localVarPath = `/api/branches`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BranchControllerApi - functional programming interface
 * @export
 */
export const BranchControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * - Get All Branch với filter
     * @summary Get All Branch với filter
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch(
      name?: string,
      address?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListBranchResponse> {
      const localVarFetchArgs = BranchControllerApiFetchParamCreator(
        configuration
      ).getAllBranch(name, address, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Branch với filter paging
     * @summary Get All Branch với filter  paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      name?: string,
      address?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseBranchDto> {
      const localVarFetchArgs = BranchControllerApiFetchParamCreator(
        configuration
      ).getAllBranch1(page, size, sort, name, address, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Branch
     * @summary Get Detail Branch
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchDetail(
      id: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseBranchResponse> {
      const localVarFetchArgs = BranchControllerApiFetchParamCreator(
        configuration
      ).getBranchDetail(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchesThatShowTheMovie(
      movieId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListBranchDto> {
      const localVarFetchArgs = BranchControllerApiFetchParamCreator(
        configuration
      ).getBranchesThatShowTheMovie(movieId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * BranchControllerApi - factory interface
 * @export
 */
export const BranchControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * - Get All Branch với filter
     * @summary Get All Branch với filter
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch(name?: string, address?: string, options?: any) {
      return BranchControllerApiFp(configuration).getAllBranch(
        name,
        address,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Branch với filter paging
     * @summary Get All Branch với filter  paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [name]
     * @param {string} [address]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllBranch1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      name?: string,
      address?: string,
      options?: any
    ) {
      return BranchControllerApiFp(configuration).getAllBranch1(
        page,
        size,
        sort,
        name,
        address,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Branch
     * @summary Get Detail Branch
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchDetail(id: number, options?: any) {
      return BranchControllerApiFp(configuration).getBranchDetail(id, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBranchesThatShowTheMovie(movieId: number, options?: any) {
      return BranchControllerApiFp(configuration).getBranchesThatShowTheMovie(
        movieId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * BranchControllerApi - object-oriented interface
 * @export
 * @class BranchControllerApi
 * @extends {BaseAPI}
 */
export class BranchControllerApi extends BaseAPI {
  /**
   * - Get All Branch với filter
   * @summary Get All Branch với filter
   * @param {string} [name]
   * @param {string} [address]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BranchControllerApi
   */
  public getAllBranch(name?: string, address?: string, options?: any) {
    return BranchControllerApiFp(this.configuration).getAllBranch(
      name,
      address,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Branch với filter paging
   * @summary Get All Branch với filter  paging
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [name]
   * @param {string} [address]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BranchControllerApi
   */
  public getAllBranch1(
    page?: number,
    size?: number,
    sort?: Array<string>,
    name?: string,
    address?: string,
    options?: any
  ) {
    return BranchControllerApiFp(this.configuration).getAllBranch1(
      page,
      size,
      sort,
      name,
      address,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Branch
   * @summary Get Detail Branch
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BranchControllerApi
   */
  public getBranchDetail(id: number, options?: any) {
    return BranchControllerApiFp(this.configuration).getBranchDetail(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} movieId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BranchControllerApi
   */
  public getBranchesThatShowTheMovie(movieId: number, options?: any) {
    return BranchControllerApiFp(
      this.configuration
    ).getBranchesThatShowTheMovie(movieId, options)(this.fetch, this.basePath);
  }
}
/**
 * InteractionControllerApi - fetch parameter creator
 * @export
 */
export const InteractionControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Kiểm tra xem user đã like bài viết đó chưa
     * @summary Kiểm tra xem user đã like bài viết đó chưa
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkLike(userId: number, articleId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling checkLike."
        );
      }
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling checkLike."
        );
      }
      const localVarPath = `/api/interaction/v1/like/checkUser`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      if (articleId !== undefined) {
        localVarQueryParameter["articleId"] = articleId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thêm bình luận
     * @summary Thêm bình luận
     * @param {AddNewCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewComment(body: AddNewCommentRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNewComment."
        );
      }
      const localVarPath = `/api/interaction/v1/comment/add`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewCommentRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Thích và hủy thích bài viết
     * @summary Like - unlike bài viết
     * @param {AddNewLikeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike(body: AddNewLikeRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling createNewLike."
        );
      }
      const localVarPath = `/api/interaction/v1/like/add`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewLikeRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get All Like bài viết
     * @summary get All Like bài viết
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike1(articleId: number, options: any = {}): FetchArgs {
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling createNewLike1."
        );
      }
      const localVarPath =
        `/api/interaction/v1/like/getAll/{articleId}`.replace(
          `{${"articleId"}}`,
          encodeURIComponent(String(articleId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Xoa bình luận
     * @summary Xoa bình luận
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteComment."
        );
      }
      const localVarPath = `/api/interaction/v1/comment/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * get AllComment bài viết
     * @summary get All Comment bài viết
     * @param {number} articleId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllComment(
      articleId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'articleId' is not null or undefined
      if (articleId === null || articleId === undefined) {
        throw new RequiredError(
          "articleId",
          "Required parameter articleId was null or undefined when calling getAllComment."
        );
      }
      const localVarPath =
        `/api/interaction/v1/comment/getAll/{articleId}`.replace(
          `{${"articleId"}}`,
          encodeURIComponent(String(articleId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Chỉnh sửa bình luận
     * @summary Chỉnh sửa bình luận
     * @param {UpdateCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment(body: UpdateCommentRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateComment."
        );
      }
      const localVarPath = `/api/interaction/v1/comment/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateCommentRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InteractionControllerApi - functional programming interface
 * @export
 */
export const InteractionControllerApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     * Kiểm tra xem user đã like bài viết đó chưa
     * @summary Kiểm tra xem user đã like bài viết đó chưa
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkLike(
      userId: number,
      articleId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).checkLike(userId, articleId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thêm bình luận
     * @summary Thêm bình luận
     * @param {AddNewCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewComment(
      body: AddNewCommentRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseCommentDto> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).createNewComment(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Thích và hủy thích bài viết
     * @summary Like - unlike bài viết
     * @param {AddNewLikeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike(
      body: AddNewLikeRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseLikeDto> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).createNewLike(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * get All Like bài viết
     * @summary get All Like bài viết
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike1(
      articleId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListLikeDto> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).createNewLike1(articleId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Xoa bình luận
     * @summary Xoa bình luận
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).deleteComment(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * get AllComment bài viết
     * @summary get All Comment bài viết
     * @param {number} articleId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllComment(
      articleId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseCommentDto> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).getAllComment(articleId, page, size, sort, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Chỉnh sửa bình luận
     * @summary Chỉnh sửa bình luận
     * @param {UpdateCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment(
      body: UpdateCommentRequest,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseCommentDto> {
      const localVarFetchArgs = InteractionControllerApiFetchParamCreator(
        configuration
      ).updateComment(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * InteractionControllerApi - factory interface
 * @export
 */
export const InteractionControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Kiểm tra xem user đã like bài viết đó chưa
     * @summary Kiểm tra xem user đã like bài viết đó chưa
     * @param {number} userId
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkLike(userId: number, articleId: number, options?: any) {
      return InteractionControllerApiFp(configuration).checkLike(
        userId,
        articleId,
        options
      )(fetch, basePath);
    },
    /**
     * - Thêm bình luận
     * @summary Thêm bình luận
     * @param {AddNewCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewComment(body: AddNewCommentRequest, options?: any) {
      return InteractionControllerApiFp(configuration).createNewComment(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Thích và hủy thích bài viết
     * @summary Like - unlike bài viết
     * @param {AddNewLikeRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike(body: AddNewLikeRequest, options?: any) {
      return InteractionControllerApiFp(configuration).createNewLike(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * get All Like bài viết
     * @summary get All Like bài viết
     * @param {number} articleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createNewLike1(articleId: number, options?: any) {
      return InteractionControllerApiFp(configuration).createNewLike1(
        articleId,
        options
      )(fetch, basePath);
    },
    /**
     * - Xoa bình luận
     * @summary Xoa bình luận
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComment(id: number, options?: any) {
      return InteractionControllerApiFp(configuration).deleteComment(
        id,
        options
      )(fetch, basePath);
    },
    /**
     * get AllComment bài viết
     * @summary get All Comment bài viết
     * @param {number} articleId
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllComment(
      articleId: number,
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ) {
      return InteractionControllerApiFp(configuration).getAllComment(
        articleId,
        page,
        size,
        sort,
        options
      )(fetch, basePath);
    },
    /**
     * - Chỉnh sửa bình luận
     * @summary Chỉnh sửa bình luận
     * @param {UpdateCommentRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateComment(body: UpdateCommentRequest, options?: any) {
      return InteractionControllerApiFp(configuration).updateComment(
        body,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * InteractionControllerApi - object-oriented interface
 * @export
 * @class InteractionControllerApi
 * @extends {BaseAPI}
 */
export class InteractionControllerApi extends BaseAPI {
  /**
   * Kiểm tra xem user đã like bài viết đó chưa
   * @summary Kiểm tra xem user đã like bài viết đó chưa
   * @param {number} userId
   * @param {number} articleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public checkLike(userId: number, articleId: number, options?: any) {
    return InteractionControllerApiFp(this.configuration).checkLike(
      userId,
      articleId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thêm bình luận
   * @summary Thêm bình luận
   * @param {AddNewCommentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public createNewComment(body: AddNewCommentRequest, options?: any) {
    return InteractionControllerApiFp(this.configuration).createNewComment(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Thích và hủy thích bài viết
   * @summary Like - unlike bài viết
   * @param {AddNewLikeRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public createNewLike(body: AddNewLikeRequest, options?: any) {
    return InteractionControllerApiFp(this.configuration).createNewLike(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * get All Like bài viết
   * @summary get All Like bài viết
   * @param {number} articleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public createNewLike1(articleId: number, options?: any) {
    return InteractionControllerApiFp(this.configuration).createNewLike1(
      articleId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Xoa bình luận
   * @summary Xoa bình luận
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public deleteComment(id: number, options?: any) {
    return InteractionControllerApiFp(this.configuration).deleteComment(
      id,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * get AllComment bài viết
   * @summary get All Comment bài viết
   * @param {number} articleId
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public getAllComment(
    articleId: number,
    page?: number,
    size?: number,
    sort?: Array<string>,
    options?: any
  ) {
    return InteractionControllerApiFp(this.configuration).getAllComment(
      articleId,
      page,
      size,
      sort,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Chỉnh sửa bình luận
   * @summary Chỉnh sửa bình luận
   * @param {UpdateCommentRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InteractionControllerApi
   */
  public updateComment(body: UpdateCommentRequest, options?: any) {
    return InteractionControllerApiFp(this.configuration).updateComment(
      body,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * MovieControllerApi - fetch parameter creator
 * @export
 */
export const MovieControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {AddNewMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewMovie(body: AddNewMovieRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling addNewMovie."
        );
      }
      const localVarPath = `/api/movies/addNew`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"AddNewMovieRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMovie(movieId: number, options: any = {}): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling deleteMovie."
        );
      }
      const localVarPath = `/api/movies/{movieId}`.replace(
        `{${"movieId"}}`,
        encodeURIComponent(String(movieId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Movie với filter (List)
     * @summary Get All Movie với filter (List)
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMovies(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/movies/getList`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (actors !== undefined) {
        localVarQueryParameter["actors"] = actors;
      }

      if (categories !== undefined) {
        localVarQueryParameter["categories"] = categories;
      }

      if (director !== undefined) {
        localVarQueryParameter["director"] = director;
      }

      if (isShowing !== undefined) {
        localVarQueryParameter["isShowing"] = isShowing;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Movie với filter và paging
     * @summary Get All Movie với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMoviesPaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/movies/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (actors !== undefined) {
        localVarQueryParameter["actors"] = actors;
      }

      if (categories !== undefined) {
        localVarQueryParameter["categories"] = categories;
      }

      if (director !== undefined) {
        localVarQueryParameter["director"] = director;
      }

      if (isShowing !== undefined) {
        localVarQueryParameter["isShowing"] = isShowing;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMovies(options: any = {}): FetchArgs {
      const localVarPath = `/api/movies/showing`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMoviesByName(name: string, options: any = {}): FetchArgs {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          "name",
          "Required parameter name was null or undefined when calling findAllShowingMoviesByName."
        );
      }
      const localVarPath = `/api/movies/showing/search`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMovieById(movieId: number, options: any = {}): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling getMovieById."
        );
      }
      const localVarPath = `/api/movies/details/{movieId}`.replace(
        `{${"movieId"}}`,
        encodeURIComponent(String(movieId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMovie(body: UpdateMovieRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateMovie."
        );
      }
      const localVarPath = `/api/movies/update`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateMovieRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MovieControllerApi - functional programming interface
 * @export
 */
export const MovieControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {AddNewMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewMovie(
      body: AddNewMovieRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).addNewMovie(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMovie(
      movieId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).deleteMovie(movieId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Movie với filter (List)
     * @summary Get All Movie với filter (List)
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMovies(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).findAllMovies(
        page,
        size,
        sort,
        actors,
        categories,
        director,
        isShowing,
        name,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Movie với filter và paging
     * @summary Get All Movie với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMoviesPaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).findAllMoviesPaging(
        page,
        size,
        sort,
        actors,
        categories,
        director,
        isShowing,
        name,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMovies(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListMovieDto> {
      const localVarFetchArgs =
        MovieControllerApiFetchParamCreator(configuration).findAllShowingMovies(
          options
        );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMoviesByName(
      name: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).findAllShowingMoviesByName(name, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMovieById(
      movieId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).getMovieById(movieId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {UpdateMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMovie(
      body: UpdateMovieRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseMovieDto> {
      const localVarFetchArgs = MovieControllerApiFetchParamCreator(
        configuration
      ).updateMovie(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * MovieControllerApi - factory interface
 * @export
 */
export const MovieControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {AddNewMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewMovie(body: AddNewMovieRequest, options?: any) {
      return MovieControllerApiFp(configuration).addNewMovie(body, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteMovie(movieId: number, options?: any) {
      return MovieControllerApiFp(configuration).deleteMovie(movieId, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Get All Movie với filter (List)
     * @summary Get All Movie với filter (List)
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMovies(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options?: any
    ) {
      return MovieControllerApiFp(configuration).findAllMovies(
        page,
        size,
        sort,
        actors,
        categories,
        director,
        isShowing,
        name,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Movie với filter và paging
     * @summary Get All Movie với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [actors]
     * @param {string} [categories]
     * @param {string} [director]
     * @param {number} [isShowing]
     * @param {string} [name]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllMoviesPaging(
      page?: number,
      size?: number,
      sort?: Array<string>,
      actors?: string,
      categories?: string,
      director?: string,
      isShowing?: number,
      name?: string,
      options?: any
    ) {
      return MovieControllerApiFp(configuration).findAllMoviesPaging(
        page,
        size,
        sort,
        actors,
        categories,
        director,
        isShowing,
        name,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMovies(options?: any) {
      return MovieControllerApiFp(configuration).findAllShowingMovies(options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    findAllShowingMoviesByName(name: string, options?: any) {
      return MovieControllerApiFp(configuration).findAllShowingMoviesByName(
        name,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {number} movieId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getMovieById(movieId: number, options?: any) {
      return MovieControllerApiFp(configuration).getMovieById(movieId, options)(
        fetch,
        basePath
      );
    },
    /**
     *
     * @param {UpdateMovieRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateMovie(body: UpdateMovieRequest, options?: any) {
      return MovieControllerApiFp(configuration).updateMovie(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * MovieControllerApi - object-oriented interface
 * @export
 * @class MovieControllerApi
 * @extends {BaseAPI}
 */
export class MovieControllerApi extends BaseAPI {
  /**
   *
   * @param {AddNewMovieRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public addNewMovie(body: AddNewMovieRequest, options?: any) {
    return MovieControllerApiFp(this.configuration).addNewMovie(body, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   *
   * @param {number} movieId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public deleteMovie(movieId: number, options?: any) {
    return MovieControllerApiFp(this.configuration).deleteMovie(
      movieId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Movie với filter (List)
   * @summary Get All Movie với filter (List)
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [actors]
   * @param {string} [categories]
   * @param {string} [director]
   * @param {number} [isShowing]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public findAllMovies(
    page?: number,
    size?: number,
    sort?: Array<string>,
    actors?: string,
    categories?: string,
    director?: string,
    isShowing?: number,
    name?: string,
    options?: any
  ) {
    return MovieControllerApiFp(this.configuration).findAllMovies(
      page,
      size,
      sort,
      actors,
      categories,
      director,
      isShowing,
      name,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Movie với filter và paging
   * @summary Get All Movie với filter và paging
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [actors]
   * @param {string} [categories]
   * @param {string} [director]
   * @param {number} [isShowing]
   * @param {string} [name]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public findAllMoviesPaging(
    page?: number,
    size?: number,
    sort?: Array<string>,
    actors?: string,
    categories?: string,
    director?: string,
    isShowing?: number,
    name?: string,
    options?: any
  ) {
    return MovieControllerApiFp(this.configuration).findAllMoviesPaging(
      page,
      size,
      sort,
      actors,
      categories,
      director,
      isShowing,
      name,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public findAllShowingMovies(options?: any) {
    return MovieControllerApiFp(this.configuration).findAllShowingMovies(
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public findAllShowingMoviesByName(name: string, options?: any) {
    return MovieControllerApiFp(this.configuration).findAllShowingMoviesByName(
      name,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} movieId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public getMovieById(movieId: number, options?: any) {
    return MovieControllerApiFp(this.configuration).getMovieById(
      movieId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {UpdateMovieRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MovieControllerApi
   */
  public updateMovie(body: UpdateMovieRequest, options?: any) {
    return MovieControllerApiFp(this.configuration).updateMovie(body, options)(
      this.fetch,
      this.basePath
    );
  }
}
/**
 * RoomControllerApi - fetch parameter creator
 * @export
 */
export const RoomControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {string} startTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRooms(
      movieId: number,
      branchId: number,
      startDate: string,
      startTime: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling getRooms."
        );
      }
      // verify required parameter 'branchId' is not null or undefined
      if (branchId === null || branchId === undefined) {
        throw new RequiredError(
          "branchId",
          "Required parameter branchId was null or undefined when calling getRooms."
        );
      }
      // verify required parameter 'startDate' is not null or undefined
      if (startDate === null || startDate === undefined) {
        throw new RequiredError(
          "startDate",
          "Required parameter startDate was null or undefined when calling getRooms."
        );
      }
      // verify required parameter 'startTime' is not null or undefined
      if (startTime === null || startTime === undefined) {
        throw new RequiredError(
          "startTime",
          "Required parameter startTime was null or undefined when calling getRooms."
        );
      }
      const localVarPath = `/api/rooms`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (startTime !== undefined) {
        localVarQueryParameter["startTime"] = startTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy Danh sach Room by Branch Id
     * @summary Lấy Danh sach Room by Branch Id
     * @param {number} branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoomsByBranch(branchId: number, options: any = {}): FetchArgs {
      // verify required parameter 'branchId' is not null or undefined
      if (branchId === null || branchId === undefined) {
        throw new RequiredError(
          "branchId",
          "Required parameter branchId was null or undefined when calling getRoomsByBranch."
        );
      }
      const localVarPath = `/api/rooms/branch`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * RoomControllerApi - functional programming interface
 * @export
 */
export const RoomControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {string} startTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRooms(
      movieId: number,
      branchId: number,
      startDate: string,
      startTime: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoomDto>> {
      const localVarFetchArgs = RoomControllerApiFetchParamCreator(
        configuration
      ).getRooms(movieId, branchId, startDate, startTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy Danh sach Room by Branch Id
     * @summary Lấy Danh sach Room by Branch Id
     * @param {number} branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoomsByBranch(
      branchId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RoomDto>> {
      const localVarFetchArgs = RoomControllerApiFetchParamCreator(
        configuration
      ).getRoomsByBranch(branchId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * RoomControllerApi - factory interface
 * @export
 */
export const RoomControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {string} startTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRooms(
      movieId: number,
      branchId: number,
      startDate: string,
      startTime: string,
      options?: any
    ) {
      return RoomControllerApiFp(configuration).getRooms(
        movieId,
        branchId,
        startDate,
        startTime,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy Danh sach Room by Branch Id
     * @summary Lấy Danh sach Room by Branch Id
     * @param {number} branchId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoomsByBranch(branchId: number, options?: any) {
      return RoomControllerApiFp(configuration).getRoomsByBranch(
        branchId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * RoomControllerApi - object-oriented interface
 * @export
 * @class RoomControllerApi
 * @extends {BaseAPI}
 */
export class RoomControllerApi extends BaseAPI {
  /**
   *
   * @param {number} movieId
   * @param {number} branchId
   * @param {string} startDate
   * @param {string} startTime
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoomControllerApi
   */
  public getRooms(
    movieId: number,
    branchId: number,
    startDate: string,
    startTime: string,
    options?: any
  ) {
    return RoomControllerApiFp(this.configuration).getRooms(
      movieId,
      branchId,
      startDate,
      startTime,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy Danh sach Room by Branch Id
   * @summary Lấy Danh sach Room by Branch Id
   * @param {number} branchId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoomControllerApi
   */
  public getRoomsByBranch(branchId: number, options?: any) {
    return RoomControllerApiFp(this.configuration).getRoomsByBranch(
      branchId,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * ScheduleControllerApi - fetch parameter creator
 * @export
 */
export const ScheduleControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Thêm mới lịch chiếu phim
     * @summary Thêm mới lịch chiếu
     * @param {number} movieId
     * @param {number} branchId
     * @param {number} roomId
     * @param {string} startDate
     * @param {string} startTime
     * @param {number} [price]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewSchedule(
      movieId: number,
      branchId: number,
      roomId: number,
      startDate: string,
      startTime: string,
      price?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling addNewSchedule."
        );
      }
      // verify required parameter 'branchId' is not null or undefined
      if (branchId === null || branchId === undefined) {
        throw new RequiredError(
          "branchId",
          "Required parameter branchId was null or undefined when calling addNewSchedule."
        );
      }
      // verify required parameter 'roomId' is not null or undefined
      if (roomId === null || roomId === undefined) {
        throw new RequiredError(
          "roomId",
          "Required parameter roomId was null or undefined when calling addNewSchedule."
        );
      }
      // verify required parameter 'startDate' is not null or undefined
      if (startDate === null || startDate === undefined) {
        throw new RequiredError(
          "startDate",
          "Required parameter startDate was null or undefined when calling addNewSchedule."
        );
      }
      // verify required parameter 'startTime' is not null or undefined
      if (startTime === null || startTime === undefined) {
        throw new RequiredError(
          "startTime",
          "Required parameter startTime was null or undefined when calling addNewSchedule."
        );
      }
      const localVarPath = `/api/schedule/add`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      if (roomId !== undefined) {
        localVarQueryParameter["roomId"] = roomId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (startTime !== undefined) {
        localVarQueryParameter["startTime"] = startTime;
      }

      if (price !== undefined) {
        localVarQueryParameter["price"] = price;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Schedule với filter
     * @summary Get All Schedule với filter (List)
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules(
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/schedule`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (startTime !== undefined) {
        localVarQueryParameter["startTime"] = startTime;
      }

      if (roomId !== undefined) {
        localVarQueryParameter["roomId"] = roomId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get All Schedule với filter và paging
     * @summary Get All Schedule với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/schedule/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      if (startTime !== undefined) {
        localVarQueryParameter["startTime"] = startTime;
      }

      if (roomId !== undefined) {
        localVarQueryParameter["roomId"] = roomId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStartTimes(
      movieId: number,
      branchId: number,
      startDate: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'movieId' is not null or undefined
      if (movieId === null || movieId === undefined) {
        throw new RequiredError(
          "movieId",
          "Required parameter movieId was null or undefined when calling getStartTimes."
        );
      }
      // verify required parameter 'branchId' is not null or undefined
      if (branchId === null || branchId === undefined) {
        throw new RequiredError(
          "branchId",
          "Required parameter branchId was null or undefined when calling getStartTimes."
        );
      }
      // verify required parameter 'startDate' is not null or undefined
      if (startDate === null || startDate === undefined) {
        throw new RequiredError(
          "startDate",
          "Required parameter startDate was null or undefined when calling getStartTimes."
        );
      }
      const localVarPath = `/api/schedule/start-times`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (movieId !== undefined) {
        localVarQueryParameter["movieId"] = movieId;
      }

      if (branchId !== undefined) {
        localVarQueryParameter["branchId"] = branchId;
      }

      if (startDate !== undefined) {
        localVarQueryParameter["startDate"] = startDate;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScheduleControllerApi - functional programming interface
 * @export
 */
export const ScheduleControllerApiFp = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Thêm mới lịch chiếu phim
     * @summary Thêm mới lịch chiếu
     * @param {number} movieId
     * @param {number} branchId
     * @param {number} roomId
     * @param {string} startDate
     * @param {string} startTime
     * @param {number} [price]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewSchedule(
      movieId: number,
      branchId: number,
      roomId: number,
      startDate: string,
      startTime: string,
      price?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseScheduleDto> {
      const localVarFetchArgs = ScheduleControllerApiFetchParamCreator(
        configuration
      ).addNewSchedule(
        movieId,
        branchId,
        roomId,
        startDate,
        startTime,
        price,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Schedule với filter
     * @summary Get All Schedule với filter (List)
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules(
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListScheduleDto> {
      const localVarFetchArgs = ScheduleControllerApiFetchParamCreator(
        configuration
      ).getSchedules(movieId, branchId, startDate, startTime, roomId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get All Schedule với filter và paging
     * @summary Get All Schedule với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseScheduleDto> {
      const localVarFetchArgs = ScheduleControllerApiFetchParamCreator(
        configuration
      ).getSchedules1(
        page,
        size,
        sort,
        movieId,
        branchId,
        startDate,
        startTime,
        roomId,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStartTimes(
      movieId: number,
      branchId: number,
      startDate: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
      const localVarFetchArgs = ScheduleControllerApiFetchParamCreator(
        configuration
      ).getStartTimes(movieId, branchId, startDate, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * ScheduleControllerApi - factory interface
 * @export
 */
export const ScheduleControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * - Thêm mới lịch chiếu phim
     * @summary Thêm mới lịch chiếu
     * @param {number} movieId
     * @param {number} branchId
     * @param {number} roomId
     * @param {string} startDate
     * @param {string} startTime
     * @param {number} [price]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addNewSchedule(
      movieId: number,
      branchId: number,
      roomId: number,
      startDate: string,
      startTime: string,
      price?: number,
      options?: any
    ) {
      return ScheduleControllerApiFp(configuration).addNewSchedule(
        movieId,
        branchId,
        roomId,
        startDate,
        startTime,
        price,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Schedule với filter
     * @summary Get All Schedule với filter (List)
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules(
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options?: any
    ) {
      return ScheduleControllerApiFp(configuration).getSchedules(
        movieId,
        branchId,
        startDate,
        startTime,
        roomId,
        options
      )(fetch, basePath);
    },
    /**
     * - Get All Schedule với filter và paging
     * @summary Get All Schedule với filter và paging
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {number} [movieId]
     * @param {number} [branchId]
     * @param {string} [startDate]
     * @param {string} [startTime]
     * @param {number} [roomId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSchedules1(
      page?: number,
      size?: number,
      sort?: Array<string>,
      movieId?: number,
      branchId?: number,
      startDate?: string,
      startTime?: string,
      roomId?: number,
      options?: any
    ) {
      return ScheduleControllerApiFp(configuration).getSchedules1(
        page,
        size,
        sort,
        movieId,
        branchId,
        startDate,
        startTime,
        roomId,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {number} movieId
     * @param {number} branchId
     * @param {string} startDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStartTimes(
      movieId: number,
      branchId: number,
      startDate: string,
      options?: any
    ) {
      return ScheduleControllerApiFp(configuration).getStartTimes(
        movieId,
        branchId,
        startDate,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * ScheduleControllerApi - object-oriented interface
 * @export
 * @class ScheduleControllerApi
 * @extends {BaseAPI}
 */
export class ScheduleControllerApi extends BaseAPI {
  /**
   * - Thêm mới lịch chiếu phim
   * @summary Thêm mới lịch chiếu
   * @param {number} movieId
   * @param {number} branchId
   * @param {number} roomId
   * @param {string} startDate
   * @param {string} startTime
   * @param {number} [price]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScheduleControllerApi
   */
  public addNewSchedule(
    movieId: number,
    branchId: number,
    roomId: number,
    startDate: string,
    startTime: string,
    price?: number,
    options?: any
  ) {
    return ScheduleControllerApiFp(this.configuration).addNewSchedule(
      movieId,
      branchId,
      roomId,
      startDate,
      startTime,
      price,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Schedule với filter
   * @summary Get All Schedule với filter (List)
   * @param {number} [movieId]
   * @param {number} [branchId]
   * @param {string} [startDate]
   * @param {string} [startTime]
   * @param {number} [roomId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScheduleControllerApi
   */
  public getSchedules(
    movieId?: number,
    branchId?: number,
    startDate?: string,
    startTime?: string,
    roomId?: number,
    options?: any
  ) {
    return ScheduleControllerApiFp(this.configuration).getSchedules(
      movieId,
      branchId,
      startDate,
      startTime,
      roomId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get All Schedule với filter và paging
   * @summary Get All Schedule với filter và paging
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {number} [movieId]
   * @param {number} [branchId]
   * @param {string} [startDate]
   * @param {string} [startTime]
   * @param {number} [roomId]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScheduleControllerApi
   */
  public getSchedules1(
    page?: number,
    size?: number,
    sort?: Array<string>,
    movieId?: number,
    branchId?: number,
    startDate?: string,
    startTime?: string,
    roomId?: number,
    options?: any
  ) {
    return ScheduleControllerApiFp(this.configuration).getSchedules1(
      page,
      size,
      sort,
      movieId,
      branchId,
      startDate,
      startTime,
      roomId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {number} movieId
   * @param {number} branchId
   * @param {string} startDate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScheduleControllerApi
   */
  public getStartTimes(
    movieId: number,
    branchId: number,
    startDate: string,
    options?: any
  ) {
    return ScheduleControllerApiFp(this.configuration).getStartTimes(
      movieId,
      branchId,
      startDate,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * SeatControllerApi - fetch parameter creator
 * @export
 */
export const SeatControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @param {number} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeatsByScheduleId(scheduleId: number, options: any = {}): FetchArgs {
      // verify required parameter 'scheduleId' is not null or undefined
      if (scheduleId === null || scheduleId === undefined) {
        throw new RequiredError(
          "scheduleId",
          "Required parameter scheduleId was null or undefined when calling getSeatsByScheduleId."
        );
      }
      const localVarPath = `/api/seats`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (scheduleId !== undefined) {
        localVarQueryParameter["scheduleId"] = scheduleId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SeatControllerApi - functional programming interface
 * @export
 */
export const SeatControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {number} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeatsByScheduleId(
      scheduleId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListSeatDto> {
      const localVarFetchArgs = SeatControllerApiFetchParamCreator(
        configuration
      ).getSeatsByScheduleId(scheduleId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * SeatControllerApi - factory interface
 * @export
 */
export const SeatControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {number} scheduleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSeatsByScheduleId(scheduleId: number, options?: any) {
      return SeatControllerApiFp(configuration).getSeatsByScheduleId(
        scheduleId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * SeatControllerApi - object-oriented interface
 * @export
 * @class SeatControllerApi
 * @extends {BaseAPI}
 */
export class SeatControllerApi extends BaseAPI {
  /**
   *
   * @param {number} scheduleId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SeatControllerApi
   */
  public getSeatsByScheduleId(scheduleId: number, options?: any) {
    return SeatControllerApiFp(this.configuration).getSeatsByScheduleId(
      scheduleId,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * TicketControllerApi - fetch parameter creator
 * @export
 */
export const TicketControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Lấy ra all danh sách vé xem phim
     * @summary Lấy all danh sách vé xem phim
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTicket(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/tickets/getList`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy ra danh sách vé xem phim của user đó
     * @summary Lấy danh sách vé xem phim
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketsByUserId(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling getTicketsByUserId."
        );
      }
      const localVarPath = `/api/tickets`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (userId !== undefined) {
        localVarQueryParameter["userId"] = userId;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TicketControllerApi - functional programming interface
 * @export
 */
export const TicketControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * - Lấy ra all danh sách vé xem phim
     * @summary Lấy all danh sách vé xem phim
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTicket(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseTicketDto> {
      const localVarFetchArgs = TicketControllerApiFetchParamCreator(
        configuration
      ).getAllTicket(page, size, sort, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy ra danh sách vé xem phim của user đó
     * @summary Lấy danh sách vé xem phim
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketsByUserId(
      userId: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListTicketDto> {
      const localVarFetchArgs = TicketControllerApiFetchParamCreator(
        configuration
      ).getTicketsByUserId(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * TicketControllerApi - factory interface
 * @export
 */
export const TicketControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * - Lấy ra all danh sách vé xem phim
     * @summary Lấy all danh sách vé xem phim
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllTicket(
      page?: number,
      size?: number,
      sort?: Array<string>,
      options?: any
    ) {
      return TicketControllerApiFp(configuration).getAllTicket(
        page,
        size,
        sort,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy ra danh sách vé xem phim của user đó
     * @summary Lấy danh sách vé xem phim
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTicketsByUserId(userId: number, options?: any) {
      return TicketControllerApiFp(configuration).getTicketsByUserId(
        userId,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * TicketControllerApi - object-oriented interface
 * @export
 * @class TicketControllerApi
 * @extends {BaseAPI}
 */
export class TicketControllerApi extends BaseAPI {
  /**
   * - Lấy ra all danh sách vé xem phim
   * @summary Lấy all danh sách vé xem phim
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketControllerApi
   */
  public getAllTicket(
    page?: number,
    size?: number,
    sort?: Array<string>,
    options?: any
  ) {
    return TicketControllerApiFp(this.configuration).getAllTicket(
      page,
      size,
      sort,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy ra danh sách vé xem phim của user đó
   * @summary Lấy danh sách vé xem phim
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TicketControllerApi
   */
  public getTicketsByUserId(userId: number, options?: any) {
    return TicketControllerApiFp(this.configuration).getTicketsByUserId(
      userId,
      options
    )(this.fetch, this.basePath);
  }
}
/**
 * UserControllerApi - fetch parameter creator
 * @export
 */
export const UserControllerApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * - Kiểm tra xem email đã được sử dụng hay chưa
     * @summary Kiểm tra email
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEmailAvailability(email: string, options: any = {}): FetchArgs {
      // verify required parameter 'email' is not null or undefined
      if (email === null || email === undefined) {
        throw new RequiredError(
          "email",
          "Required parameter email was null or undefined when calling checkEmailAvailability."
        );
      }
      const localVarPath = `/api/user/checkEmailAvailability`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Kiểm tra xem username đã được sử dụng hay chưa
     * @summary Kiểm tra username
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameAvailability(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          "username",
          "Required parameter username was null or undefined when calling checkUsernameAvailability."
        );
      }
      const localVarPath = `/api/user/checkUsernameAvailability`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Xóa một User
     * @summary Xóa một User
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling deleteUser."
        );
      }
      const localVarPath = `/api/user/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get toàn bộ user
     * @summary Get toàn bộ user
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUser(
      username?: string,
      name?: string,
      email?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/user/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get toàn bộ user đang xin quyền viết bài
     * @summary Get toàn bộ user đang xin quyền viết bài
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserWaiting(
      page?: number,
      size?: number,
      sort?: Array<string>,
      username?: string,
      name?: string,
      email?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/api/user/contenCreator/waiting/getAll`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (page !== undefined) {
        localVarQueryParameter["page"] = page;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (sort) {
        localVarQueryParameter["sort"] = sort;
      }

      if (username !== undefined) {
        localVarQueryParameter["username"] = username;
      }

      if (name !== undefined) {
        localVarQueryParameter["name"] = name;
      }

      if (email !== undefined) {
        localVarQueryParameter["email"] = email;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Lấy thông tin user hiện tại đang đăng nhập
     * @summary Lấy thông tin user hiện tại
     * @param {UserPrincipal} currentUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(currentUser: UserPrincipal, options: any = {}): FetchArgs {
      // verify required parameter 'currentUser' is not null or undefined
      if (currentUser === null || currentUser === undefined) {
        throw new RequiredError(
          "currentUser",
          "Required parameter currentUser was null or undefined when calling getCurrentUser."
        );
      }
      const localVarPath = `/api/user/me`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (currentUser !== undefined) {
        localVarQueryParameter["currentUser"] = currentUser;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get chi tiết user by username
     * @summary Get chi tiết user
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(username: string, options: any = {}): FetchArgs {
      // verify required parameter 'username' is not null or undefined
      if (username === null || username === undefined) {
        throw new RequiredError(
          "username",
          "Required parameter username was null or undefined when calling getUserProfile."
        );
      }
      const localVarPath = `/api/user/{username}`.replace(
        `{${"username"}}`,
        encodeURIComponent(String(username))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Get dashboard user
     * @summary Get danh sach user xếp theo tổng số lượng bài viết của tháng
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserReport(dateTime: string, options: any = {}): FetchArgs {
      // verify required parameter 'dateTime' is not null or undefined
      if (dateTime === null || dateTime === undefined) {
        throw new RequiredError(
          "dateTime",
          "Required parameter dateTime was null or undefined when calling getUserReport."
        );
      }
      const localVarPath = `/api/user/dashBoard`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      if (dateTime !== undefined) {
        localVarQueryParameter["dateTime"] = dateTime;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @param {UpdateCategoryRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategory(body: UpdateCategoryRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateCategory."
        );
      }
      const localVarPath = `/api/user/updateCategory`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateCategoryRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Xin Cấp quyền viết
     * @summary Xin Cấp quyền viết bài
     * @param {SendContentCreatorRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator(
      body: SendContentCreatorRequest,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateContentCreator."
        );
      }
      const localVarPath = `/api/user/contentAccess`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"SendContentCreatorRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Cấp quyền viết bài cho user
     * @summary Cấp quyền viết bài cho user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator1(userId: number, options: any = {}): FetchArgs {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          "userId",
          "Required parameter userId was null or undefined when calling updateContentCreator1."
        );
      }
      const localVarPath = `/api/user/contentAccess/{userId}`.replace(
        `{${"userId"}}`,
        encodeURIComponent(String(userId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * - Chỉnh sửa thông tin User
     * @summary Chỉnh sửa thông tin User
     * @param {UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfoUser(body: UpdateUserRequest, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          "body",
          "Required parameter body was null or undefined when calling updateInfoUser."
        );
      }
      const localVarPath = `/api/user/updateInfo`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      (localVarUrlObj as any).search = undefined;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"UpdateUserRequest" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * - Kiểm tra xem email đã được sử dụng hay chưa
     * @summary Kiểm tra email
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEmailAvailability(
      email: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<UserIdentityAvailability> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).checkEmailAvailability(email, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Kiểm tra xem username đã được sử dụng hay chưa
     * @summary Kiểm tra username
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameAvailability(
      username: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<UserIdentityAvailability> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).checkUsernameAvailability(username, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Xóa một User
     * @summary Xóa một User
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(
      id: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).deleteUser(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get toàn bộ user
     * @summary Get toàn bộ user
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUser(
      username?: string,
      name?: string,
      email?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getAllUser(username, name, email, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get toàn bộ user đang xin quyền viết bài
     * @summary Get toàn bộ user đang xin quyền viết bài
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserWaiting(
      page?: number,
      size?: number,
      sort?: Array<string>,
      username?: string,
      name?: string,
      email?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBasePageResponseUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getAllUserWaiting(page, size, sort, username, name, email, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Lấy thông tin user hiện tại đang đăng nhập
     * @summary Lấy thông tin user hiện tại
     * @param {UserPrincipal} currentUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(
      currentUser: UserPrincipal,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseUserSummary> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getCurrentUser(currentUser, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get chi tiết user by username
     * @summary Get chi tiết user
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(
      username: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getUserProfile(username, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Get dashboard user
     * @summary Get danh sach user xếp theo tổng số lượng bài viết của tháng
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserReport(
      dateTime: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ResponseBaseListUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).getUserReport(dateTime, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     *
     * @param {UpdateCategoryRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategory(
      body: UpdateCategoryRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).updateCategory(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Xin Cấp quyền viết
     * @summary Xin Cấp quyền viết bài
     * @param {SendContentCreatorRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator(
      body: SendContentCreatorRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResponse> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).updateContentCreator(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Cấp quyền viết bài cho user
     * @summary Cấp quyền viết bài cho user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator1(
      userId: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).updateContentCreator1(userId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * - Chỉnh sửa thông tin User
     * @summary Chỉnh sửa thông tin User
     * @param {UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfoUser(
      body: UpdateUserRequest,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseBaseUserDto> {
      const localVarFetchArgs = UserControllerApiFetchParamCreator(
        configuration
      ).updateInfoUser(body, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * - Kiểm tra xem email đã được sử dụng hay chưa
     * @summary Kiểm tra email
     * @param {string} email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkEmailAvailability(email: string, options?: any) {
      return UserControllerApiFp(configuration).checkEmailAvailability(
        email,
        options
      )(fetch, basePath);
    },
    /**
     * - Kiểm tra xem username đã được sử dụng hay chưa
     * @summary Kiểm tra username
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    checkUsernameAvailability(username: string, options?: any) {
      return UserControllerApiFp(configuration).checkUsernameAvailability(
        username,
        options
      )(fetch, basePath);
    },
    /**
     * - Xóa một User
     * @summary Xóa một User
     * @param {number} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(id: number, options?: any) {
      return UserControllerApiFp(configuration).deleteUser(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Get toàn bộ user
     * @summary Get toàn bộ user
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUser(
      username?: string,
      name?: string,
      email?: string,
      options?: any
    ) {
      return UserControllerApiFp(configuration).getAllUser(
        username,
        name,
        email,
        options
      )(fetch, basePath);
    },
    /**
     * - Get toàn bộ user đang xin quyền viết bài
     * @summary Get toàn bộ user đang xin quyền viết bài
     * @param {number} [page] Zero-based page index (0..N)
     * @param {number} [size] The size of the page to be returned
     * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
     * @param {string} [username]
     * @param {string} [name]
     * @param {string} [email]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAllUserWaiting(
      page?: number,
      size?: number,
      sort?: Array<string>,
      username?: string,
      name?: string,
      email?: string,
      options?: any
    ) {
      return UserControllerApiFp(configuration).getAllUserWaiting(
        page,
        size,
        sort,
        username,
        name,
        email,
        options
      )(fetch, basePath);
    },
    /**
     * - Lấy thông tin user hiện tại đang đăng nhập
     * @summary Lấy thông tin user hiện tại
     * @param {UserPrincipal} currentUser
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCurrentUser(currentUser: UserPrincipal, options?: any) {
      return UserControllerApiFp(configuration).getCurrentUser(
        currentUser,
        options
      )(fetch, basePath);
    },
    /**
     * - Get chi tiết user by username
     * @summary Get chi tiết user
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserProfile(username: string, options?: any) {
      return UserControllerApiFp(configuration).getUserProfile(
        username,
        options
      )(fetch, basePath);
    },
    /**
     * - Get dashboard user
     * @summary Get danh sach user xếp theo tổng số lượng bài viết của tháng
     * @param {string} dateTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserReport(dateTime: string, options?: any) {
      return UserControllerApiFp(configuration).getUserReport(
        dateTime,
        options
      )(fetch, basePath);
    },
    /**
     *
     * @param {UpdateCategoryRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateCategory(body: UpdateCategoryRequest, options?: any) {
      return UserControllerApiFp(configuration).updateCategory(body, options)(
        fetch,
        basePath
      );
    },
    /**
     * - Xin Cấp quyền viết
     * @summary Xin Cấp quyền viết bài
     * @param {SendContentCreatorRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator(body: SendContentCreatorRequest, options?: any) {
      return UserControllerApiFp(configuration).updateContentCreator(
        body,
        options
      )(fetch, basePath);
    },
    /**
     * - Cấp quyền viết bài cho user
     * @summary Cấp quyền viết bài cho user
     * @param {number} userId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentCreator1(userId: number, options?: any) {
      return UserControllerApiFp(configuration).updateContentCreator1(
        userId,
        options
      )(fetch, basePath);
    },
    /**
     * - Chỉnh sửa thông tin User
     * @summary Chỉnh sửa thông tin User
     * @param {UpdateUserRequest} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfoUser(body: UpdateUserRequest, options?: any) {
      return UserControllerApiFp(configuration).updateInfoUser(body, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
  /**
   * - Kiểm tra xem email đã được sử dụng hay chưa
   * @summary Kiểm tra email
   * @param {string} email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public checkEmailAvailability(email: string, options?: any) {
    return UserControllerApiFp(this.configuration).checkEmailAvailability(
      email,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Kiểm tra xem username đã được sử dụng hay chưa
   * @summary Kiểm tra username
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public checkUsernameAvailability(username: string, options?: any) {
    return UserControllerApiFp(this.configuration).checkUsernameAvailability(
      username,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Xóa một User
   * @summary Xóa một User
   * @param {number} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public deleteUser(id: number, options?: any) {
    return UserControllerApiFp(this.configuration).deleteUser(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * - Get toàn bộ user
   * @summary Get toàn bộ user
   * @param {string} [username]
   * @param {string} [name]
   * @param {string} [email]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getAllUser(
    username?: string,
    name?: string,
    email?: string,
    options?: any
  ) {
    return UserControllerApiFp(this.configuration).getAllUser(
      username,
      name,
      email,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get toàn bộ user đang xin quyền viết bài
   * @summary Get toàn bộ user đang xin quyền viết bài
   * @param {number} [page] Zero-based page index (0..N)
   * @param {number} [size] The size of the page to be returned
   * @param {Array<string>} [sort] Sorting criteria in the format: property,(asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
   * @param {string} [username]
   * @param {string} [name]
   * @param {string} [email]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getAllUserWaiting(
    page?: number,
    size?: number,
    sort?: Array<string>,
    username?: string,
    name?: string,
    email?: string,
    options?: any
  ) {
    return UserControllerApiFp(this.configuration).getAllUserWaiting(
      page,
      size,
      sort,
      username,
      name,
      email,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Lấy thông tin user hiện tại đang đăng nhập
   * @summary Lấy thông tin user hiện tại
   * @param {UserPrincipal} currentUser
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getCurrentUser(currentUser: UserPrincipal, options?: any) {
    return UserControllerApiFp(this.configuration).getCurrentUser(
      currentUser,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get chi tiết user by username
   * @summary Get chi tiết user
   * @param {string} username
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getUserProfile(username: string, options?: any) {
    return UserControllerApiFp(this.configuration).getUserProfile(
      username,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Get dashboard user
   * @summary Get danh sach user xếp theo tổng số lượng bài viết của tháng
   * @param {string} dateTime
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public getUserReport(dateTime: string, options?: any) {
    return UserControllerApiFp(this.configuration).getUserReport(
      dateTime,
      options
    )(this.fetch, this.basePath);
  }

  /**
   *
   * @param {UpdateCategoryRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateCategory(body: UpdateCategoryRequest, options?: any) {
    return UserControllerApiFp(this.configuration).updateCategory(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Xin Cấp quyền viết
   * @summary Xin Cấp quyền viết bài
   * @param {SendContentCreatorRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateContentCreator(body: SendContentCreatorRequest, options?: any) {
    return UserControllerApiFp(this.configuration).updateContentCreator(
      body,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Cấp quyền viết bài cho user
   * @summary Cấp quyền viết bài cho user
   * @param {number} userId
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateContentCreator1(userId: number, options?: any) {
    return UserControllerApiFp(this.configuration).updateContentCreator1(
      userId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * - Chỉnh sửa thông tin User
   * @summary Chỉnh sửa thông tin User
   * @param {UpdateUserRequest} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof UserControllerApi
   */
  public updateInfoUser(body: UpdateUserRequest, options?: any) {
    return UserControllerApiFp(this.configuration).updateInfoUser(
      body,
      options
    )(this.fetch, this.basePath);
  }
}
